/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 2 "tr.c"
typedef unsigned long size_t;
#line 896 "tr.c"
typedef long long JSON_int_t;
#line 927 "tr.c"
struct __anonstruct_str_653462436 {
   char *value ;
   size_t length ;
};
#line 927 "tr.c"
struct __anonstruct_vu_386608330 {
   JSON_int_t integer_value ;
   double float_value ;
   struct __anonstruct_str_653462436 str ;
};
#line 927 "tr.c"
struct JSON_value_struct {
   struct __anonstruct_vu_386608330 vu ;
};
#line 927 "tr.c"
typedef struct JSON_value_struct JSON_value;
#line 937
struct JSON_parser_struct ;
#line 937 "tr.c"
typedef struct JSON_parser_struct *JSON_parser;
#line 941 "tr.c"
struct __anonstruct_JSON_config_873012975 {
   int (*callback)(void *ctx , int type , struct JSON_value_struct  const  *value ) ;
   void *callback_ctx ;
   int depth ;
   int allow_comments ;
   int handle_floats_manually ;
   void *(*malloc)(size_t n ) ;
   void (*free)(void *mem ) ;
};
#line 941 "tr.c"
typedef struct __anonstruct_JSON_config_873012975 JSON_config;
#line 963 "tr.c"
struct __anonstruct_name_961283314 {
   char *buf ;
   size_t len ;
};
#line 963 "tr.c"
struct __anonstruct_value_961283315 {
   char *buf ;
   size_t len ;
};
#line 963
struct json_childs ;
#line 963 "tr.c"
struct json {
   struct __anonstruct_name_961283314 name ;
   struct __anonstruct_value_961283315 value ;
   struct json_childs *jchilds ;
   struct json *jfather ;
   struct json *next ;
   struct json *prev ;
};
#line 977 "tr.c"
struct json_childs {
   struct json *child ;
   struct json_childs *next ;
   unsigned int type ;
};
#line 982 "tr.c"
struct jsontring {
   char *jstring ;
   size_t jsize ;
   size_t len ;
};
#line 987
enum __anonenum_json_child_t_34874264 {
    JSON_C_T_OBJ = 0,
    JSON_C_T_ARR = 1,
    JSON_C_T_VAL = 2,
    JSON_C_T_NULL = 3
} ;
#line 987 "tr.c"
typedef enum __anonenum_json_child_t_34874264 json_child_t;
#line 993 "tr.c"
struct __anonstruct_jchild_579492347 {
   struct _json_item *child ;
   struct _json_item *head ;
   json_child_t type ;
};
#line 993 "tr.c"
struct __anonstruct_key_961283316 {
   char *val ;
   size_t len ;
};
#line 993 "tr.c"
struct _json_item {
   struct JSON_value_struct jval ;
   struct __anonstruct_jchild_579492347 jchild ;
   struct __anonstruct_key_961283316 key ;
   struct _json_item *father ;
   struct _json_item *next ;
   int type ;
};
#line 993 "tr.c"
typedef struct _json_item json_item;
#line 1008 "tr.c"
struct _json_context {
   int key_under ;
   int start_depth ;
   json_item *head ;
   json_item *current_cx ;
};
#line 1008 "tr.c"
typedef struct _json_context json_context;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 204
extern int printf(char const   * __restrict  __format  , ...) ;
#line 214
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s , size_t __maxlen , char const   * __restrict  __format  , ...) ;
#line 667
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 776
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest , void const   * __restrict  __src , size_t __n ) ;
#line 786
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s , int __c , size_t __n ) ;
#line 855
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 876
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 950
extern void init_JSON_config(JSON_config *config ) ;
#line 951
extern JSON_parser new_JSON_parser(JSON_config const   *config ) ;
#line 952
extern void delete_JSON_parser(JSON_parser jc ) ;
#line 953
extern int JSON_parser_char(JSON_parser jc , int next_char ) ;
#line 954
extern int JSON_parser_done(JSON_parser jc ) ;
#line 1014
void set_json(char const   *name , char const   *value , struct json **jprev ) ;
#line 1015
struct json *json_copy(struct json *jbase ) ;
#line 1016
void json_attach(struct json *json_father , struct json *json_child , unsigned int type ) ;
#line 1017
void json_concat(struct json *json_father , struct json *json_child ) ;
#line 1018
void json_free(struct json *jbase ) ;
#line 1019
json_item *init_json_parser(char const   *json_string ) ;
#line 1020
json_item *json_lookup(json_item *head , char *path ) ;
#line 1021
void free_json_item(json_item *cx ) ;
#line 1022
json_item *json_new_object(void) ;
#line 1023
json_item *json_new_array(void) ;
#line 1024
json_item *json_set_property_objN(json_item *obj , char const   *key , int keylen , json_item *value ) ;
#line 1025
void json_set_property_objZ(json_item *obj , char const   *key , json_item *value ) ;
#line 1026
json_item *json_set_property_strN(json_item *obj , char const   *key , int keylen , char const   *value , int valuelen ) ;
#line 1027
void json_set_property_strZ(json_item *obj , char const   *key , char const   *value ) ;
#line 1028
json_item *json_set_element_strN(json_item *obj , char const   *value , int valuelen ) ;
#line 1029
void json_set_element_strZ(json_item *obj , char const   *value ) ;
#line 1030
void json_set_element_int(json_item *obj , long value ) ;
#line 1031
void json_set_element_float(json_item *obj , long double value ) ;
#line 1032
void json_set_element_boolean(json_item *obj , int value ) ;
#line 1033
void json_set_element_null(json_item *obj ) ;
#line 1034
void json_set_element_obj(json_item *obj , json_item *value ) ;
#line 1035
json_item *json_set_property_intN(json_item *obj , char const   *key , int keylen , JSON_int_t value ) ;
#line 1036
void json_set_property_intZ(json_item *obj , char const   *key , JSON_int_t value ) ;
#line 1037
json_item *json_set_property_floatN(json_item *obj , char const   *key , int keylen , long double value ) ;
#line 1038
json_item *json_set_property_boolean(json_item *obj , char const   *key , int keylen , int value ) ;
#line 1039
json_item *json_set_property_null(json_item *obj , char const   *key , int keylen ) ;
#line 1040
struct jsontring *json_to_string(json_item *head , struct jsontring *string , int free_tree ) ;
#line 1041
json_item *json_item_copy(json_item *cx , json_item *father ) ;
#line 1042
void json_aff(json_item *cx , int depth ) ;
#line 1068
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 1092
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 1392
extern void *xmalloc(size_t size ) ;
#line 1394
extern char *xstrdup(char const   *s ) ;
#line 1397
extern long itos(long long input , char *output , long len ) ;
#line 1400
extern size_t explode(char const   split , char *input , char **tP , unsigned int limit ) ;
#line 1406 "tr.c"
void set_json(char const   *name , char const   *value , struct json **jprev ) 
{ 
  struct json *new_json ;
  struct json *old_json ;
  size_t tmp ;

  {
#line 1408
  old_json = *jprev;
#line 1409
  new_json = (struct json *)xmalloc(sizeof(struct json ));
#line 1410
  new_json->name.len = strlen(name);
#line 1411
  new_json->name.buf = (char *)xmalloc(sizeof(char ) * (new_json->name.len + 1UL));
#line 1412
  memcpy((void * __restrict  )new_json->name.buf, (void const   * __restrict  )name, new_json->name.len + 1UL);
#line 1413
  if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 1413
    tmp = strlen(value);
#line 1413
    new_json->value.len = tmp;
  } else {
#line 1413
    new_json->value.len = (size_t )0;
  }
#line 1414
  if (new_json->value.len) {
#line 1415
    new_json->value.buf = (char *)xmalloc(sizeof(char ) * (new_json->value.len + 1UL));
#line 1416
    memcpy((void * __restrict  )new_json->value.buf, (void const   * __restrict  )value, new_json->value.len + 1UL);
  } else {
#line 1418
    new_json->value.buf = (char *)((void *)0);
  }
#line 1420
  new_json->jfather = (struct json *)((void *)0);
#line 1421
  new_json->jchilds = (struct json_childs *)((void *)0);
#line 1422
  new_json->next = old_json;
#line 1423
  new_json->prev = (struct json *)((void *)0);
  {
#line 1425
  old_json->prev = new_json;
  }
#line 1427
  *jprev = new_json;
#line 1428
  return;
}
}
#line 1429 "tr.c"
struct json *json_copy(struct json *jbase ) 
{ 
  struct json *new_json ;
  struct json *tmp ;
  struct json_childs *jchilds ;
  struct json_childs *new_child ;
  struct json_childs *tmp___0 ;

  {
#line 1431
  tmp = (struct json *)xmalloc(sizeof(struct json ));
#line 1431
  new_json = tmp;
#line 1432
  jchilds = jbase->jchilds;
#line 1433
  new_json->name.len = jbase->name.len;
#line 1434
  new_json->name.buf = (char *)xmalloc(sizeof(char ) * (new_json->name.len + 1UL));
#line 1435
  memcpy((void * __restrict  )new_json->name.buf, (void const   * __restrict  )jbase->name.buf, new_json->name.len + 1UL);
#line 1436
  new_json->value.len = jbase->value.len;
#line 1437
  if (jbase->value.len) {
#line 1438
    new_json->value.buf = (char *)xmalloc(sizeof(char ) * (new_json->value.len + 1UL));
#line 1439
    memcpy((void * __restrict  )new_json->value.buf, (void const   * __restrict  )jbase->value.buf, new_json->value.len + 1UL);
  } else {
#line 1441
    new_json->value.buf = (char *)((void *)0);
  }
#line 1443
  new_json->prev = (struct json *)((void *)0);
#line 1444
  new_json->next = (struct json *)((void *)0);
#line 1445
  new_json->jfather = (struct json *)((void *)0);
#line 1446
  new_json->jchilds = (struct json_childs *)((void *)0);
#line 1447
  if (jbase->next) {
#line 1448
    new_json->next = json_copy(jbase->next);
#line 1449
    (new_json->next)->prev = new_json;
  }
#line 1451
  while ((unsigned long )jchilds != (unsigned long )((void *)0)) {
#line 1452
    tmp___0 = (struct json_childs *)xmalloc(sizeof(struct json_childs ));
#line 1452
    new_child = tmp___0;
#line 1453
    new_child->type = jchilds->type;
#line 1454
    new_child->child = json_copy(jchilds->child);
#line 1455
    (new_child->child)->jfather = new_json;
#line 1456
    new_child->next = new_json->jchilds;
#line 1457
    new_json->jchilds = new_child;
#line 1458
    jchilds = jchilds->next;
  }
#line 1460
  return (new_json);
}
}
#line 1462 "tr.c"
void json_free(struct json *jbase ) 
{ 
  struct json_childs *jchilds ;

  {
#line 1464
  jchilds = jbase->jchilds;
#line 1465
  free((void *)jbase->name.buf);
  {
#line 1467
  free((void *)jbase->value.buf);
  }
#line 1469
  if (jbase->next) {
#line 1470
    json_free(jbase->next);
  }
#line 1472
  while ((unsigned long )jchilds != (unsigned long )((void *)0)) {
#line 1473
    json_free(jchilds->child);
#line 1474
    jchilds = jchilds->next;
  }
#line 1476
  free((void *)jbase);
#line 1477
  return;
}
}
#line 1478 "tr.c"
void json_attach(struct json *json_father , struct json *json_child , unsigned int type ) 
{ 
  struct json_childs *ochild ;
  struct json_childs *nchild ;

  {
#line 1480
  ochild = json_father->jchilds;
#line 1481
  json_child->jfather = json_father;
#line 1482
  nchild = (struct json_childs *)xmalloc(sizeof(struct json_childs ));
#line 1483
  nchild->child = json_child;
#line 1484
  nchild->next = ochild;
#line 1485
  nchild->type = type;
#line 1486
  json_father->jchilds = nchild;
#line 1487
  return;
}
}
#line 1488 "tr.c"
void json_concat(struct json *json_father , struct json *json_child ) 
{ 
  struct json *jTmp ;

  {
#line 1490
  jTmp = json_father->next;
#line 1491
  if ((unsigned long )jTmp == (unsigned long )((void *)0)) {
#line 1492
    json_father->next = json_child;
#line 1493
    json_child->prev = json_father;
#line 1494
    return;
  }
#line 1496
  while ((unsigned long )jTmp != (unsigned long )((void *)0)) {
#line 1497
    if ((unsigned long )jTmp->next == (unsigned long )((void *)0)) {
#line 1498
      jTmp->next = json_child;
#line 1499
      json_child->prev = jTmp;
#line 1500
      return;
    }
#line 1502
    jTmp = jTmp->next;
  }
#line 1504
  return;
}
}
#line 1505 "tr.c"
static int json_evaluate_string_size(json_item *head ) 
{ 
  int evalsize ;
  int tmp ;

  {
#line 1507
  evalsize = 2;
#line 1508
  while ((unsigned long )head != (unsigned long )((void *)0)) {
#line 1509
    if ((unsigned long )head->key.val != (unsigned long )((void *)0)) {
#line 1510
      evalsize = (int )((size_t )evalsize + (head->key.len + 3UL));
    }
#line 1512
    if ((unsigned long )head->jval.vu.str.value != (unsigned long )((void *)0)) {
#line 1513
      evalsize = (int )((size_t )evalsize + (head->jval.vu.str.length + 3UL));
    } else
#line 1514
    if ((unsigned long )head->jchild.child == (unsigned long )((void *)0)) {
#line 1515
      evalsize += 16;
    }
#line 1517
    if ((unsigned long )head->jchild.child != (unsigned long )((void *)0)) {
#line 1518
      tmp = json_evaluate_string_size(head->jchild.child);
#line 1518
      evalsize += tmp;
    }
#line 1520
    head = head->next;
  }
#line 1522
  return (evalsize);
}
}
#line 1524 "tr.c"
static int escape_json_string(char *in , char *out , int len ) 
{ 
  int i ;
  int e ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1527
  i = 0;
#line 1527
  e = 0;
#line 1527
  while (i < len) {
#line 1528
    switch ((int )*(in + i)) {
    case 34: 
#line 1530
    tmp = e;
#line 1530
    e ++;
#line 1530
    *(out + tmp) = (char )'\\';
#line 1531
    *(out + e) = (char )'\"';
#line 1532
    break;
    case 92: 
#line 1534
    tmp___0 = e;
#line 1534
    e ++;
#line 1534
    *(out + tmp___0) = (char )'\\';
#line 1535
    *(out + e) = (char )'\\';
#line 1536
    break;
    case 10: 
#line 1538
    tmp___1 = e;
#line 1538
    e ++;
#line 1538
    *(out + tmp___1) = (char )'\\';
#line 1539
    *(out + e) = (char )'n';
#line 1540
    break;
    case 8: 
#line 1542
    tmp___2 = e;
#line 1542
    e ++;
#line 1542
    *(out + tmp___2) = (char )'\\';
#line 1543
    *(out + e) = (char )'b';
#line 1544
    break;
    case 9: 
#line 1546
    tmp___3 = e;
#line 1546
    e ++;
#line 1546
    *(out + tmp___3) = (char )'\\';
#line 1547
    *(out + e) = (char )'t';
#line 1548
    break;
    case 12: 
#line 1550
    tmp___4 = e;
#line 1550
    e ++;
#line 1550
    *(out + tmp___4) = (char )'\\';
#line 1551
    *(out + e) = (char )'f';
#line 1552
    break;
    case 13: 
#line 1554
    tmp___5 = e;
#line 1554
    e ++;
#line 1554
    *(out + tmp___5) = (char )'\\';
#line 1555
    *(out + e) = (char )'r';
#line 1556
    break;
    case 39: 
#line 1558
    tmp___6 = e;
#line 1558
    e ++;
#line 1558
    *(out + tmp___6) = (char )'\\';
#line 1559
    *(out + e) = (char )'\'';
#line 1560
    break;
    default: 
#line 1562
    *(out + e) = *(in + i);
#line 1563
    break;
    }
#line 1527
    i ++;
#line 1527
    e ++;
  }
#line 1566
  return (e);
}
}
#line 1568 "tr.c"
struct jsontring *json_to_string(json_item *head , struct jsontring *string , int free_tree ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  long l ;
  double tmp___6 ;
  double tmp___7 ;
  long tmp___8 ;
  long offset ;
  char *integer_str ;
  unsigned long __lengthofinteger_str ;
  int length ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  json_item *jtmp ;

  {
#line 1570
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 1571
    string = (struct jsontring *)xmalloc(sizeof(struct jsontring ));
#line 1572
    tmp = json_evaluate_string_size(head);
#line 1572
    string->jsize = (size_t )(tmp * 2);
#line 1573
    string->jstring = (char *)xmalloc(sizeof(char ) * (string->jsize + 1UL));
#line 1574
    string->len = (size_t )0;
  }
#line 1576
  while ((unsigned long )head != (unsigned long )((void *)0)) {
#line 1577
    if ((unsigned long )head->key.val != (unsigned long )((void *)0)) {
#line 1578
      tmp___0 = string->len;
#line 1578
      (string->len) ++;
#line 1578
      *(string->jstring + tmp___0) = (char )'\"';
#line 1579
      memcpy((void * __restrict  )(string->jstring + string->len), (void const   * __restrict  )head->key.val, head->key.len);
#line 1580
      string->len += head->key.len;
#line 1581
      tmp___1 = string->len;
#line 1581
      (string->len) ++;
#line 1581
      *(string->jstring + tmp___1) = (char )'\"';
#line 1582
      tmp___2 = string->len;
#line 1582
      (string->len) ++;
#line 1582
      *(string->jstring + tmp___2) = (char )':';
#line 1583
      if (free_tree) {
#line 1584
        free((void *)head->key.val);
      }
    }
#line 1587
    if ((unsigned long )head->jval.vu.str.value != (unsigned long )((void *)0)) {
#line 1588
      tmp___3 = string->len;
#line 1588
      (string->len) ++;
#line 1588
      *(string->jstring + tmp___3) = (char )'\"';
#line 1589
      tmp___4 = escape_json_string(head->jval.vu.str.value, string->jstring + string->len, (int )head->jval.vu.str.length);
#line 1589
      string->len += (size_t )tmp___4;
#line 1590
      tmp___5 = string->len;
#line 1590
      (string->len) ++;
#line 1590
      *(string->jstring + tmp___5) = (char )'\"';
#line 1591
      if (free_tree) {
#line 1592
        free((void *)head->jval.vu.str.value);
      }
    } else
#line 1594
    if (head->jval.vu.integer_value) {
#line 1595
      if (head->jval.vu.integer_value < 10LL) {
#line 1595
        if (head->jval.vu.integer_value >= 0LL) {
#line 1595
          tmp___8 = 1L;
        } else {
#line 1595
          tmp___6 = fabs((double )head->jval.vu.integer_value);
#line 1595
          tmp___7 = log10(tmp___6);
#line 1595
          tmp___8 = (long )tmp___7 + 1L;
        }
      } else {
#line 1595
        tmp___6 = fabs((double )head->jval.vu.integer_value);
#line 1595
        tmp___7 = log10(tmp___6);
#line 1595
        tmp___8 = (long )tmp___7 + 1L;
      }
#line 1595
      l = tmp___8;
#line 1597
      __lengthofinteger_str = (unsigned long )(l + 2L);
#line 1597
      integer_str = (char *)__builtin_alloca(sizeof(*integer_str) * __lengthofinteger_str);
#line 1598
      offset = itos(head->jval.vu.integer_value, integer_str, l + 2L);
#line 1599
      memcpy((void * __restrict  )(string->jstring + string->len), (void const   * __restrict  )(integer_str + offset), (size_t )(((l + 2L) - 1L) - offset));
#line 1600
      string->len += (size_t )(((l + 2L) - 1L) - offset);
    } else
#line 1601
    if (head->jval.vu.float_value) {
#line 1603
      length = snprintf((char * __restrict  )(string->jstring + string->len), (size_t )17, (char const   * __restrict  )"%f", head->jval.vu.float_value);
#line 1604
      if (length > 16) {
#line 1605
        length = 16;
      }
#line 1606
      string->len += (size_t )length;
    } else
#line 1607
    if (head->type == 8) {
#line 1608
      memcpy((void * __restrict  )(string->jstring + string->len), (void const   * __restrict  )"true", (size_t )4);
#line 1609
      string->len += 4UL;
    } else
#line 1610
    if (head->type == 9) {
#line 1611
      memcpy((void * __restrict  )(string->jstring + string->len), (void const   * __restrict  )"false", (size_t )5);
#line 1612
      string->len += 5UL;
    } else
#line 1613
    if (head->type == 7) {
#line 1614
      memcpy((void * __restrict  )(string->jstring + string->len), (void const   * __restrict  )"null", (size_t )4);
#line 1615
      string->len += 4UL;
    } else
#line 1616
    if ((unsigned long )head->jchild.child == (unsigned long )((void *)0)) {
#line 1617
      memcpy((void * __restrict  )(string->jstring + string->len), (void const   * __restrict  )"0", (size_t )1);
#line 1618
      (string->len) ++;
    }
#line 1620
    if ((unsigned long )head->jchild.child != (unsigned long )((void *)0)) {
#line 1621
      switch ((unsigned int )head->jchild.type) {
      case 0U: 
#line 1623
      tmp___9 = string->len;
#line 1623
      (string->len) ++;
#line 1623
      *(string->jstring + tmp___9) = (char )'{';
#line 1624
      break;
      case 1U: 
#line 1626
      tmp___10 = string->len;
#line 1626
      (string->len) ++;
#line 1626
      *(string->jstring + tmp___10) = (char )'[';
#line 1627
      break;
      default: 
#line 1629
      break;
      }
#line 1631
      json_to_string(head->jchild.child, string, free_tree);
    }
#line 1633
    if ((unsigned long )head->father != (unsigned long )((void *)0)) {
#line 1634
      if ((unsigned long )head->next != (unsigned long )((void *)0)) {
#line 1635
        tmp___11 = string->len;
#line 1635
        (string->len) ++;
#line 1635
        *(string->jstring + tmp___11) = (char )',';
      } else {
#line 1637
        switch ((unsigned int )(head->father)->jchild.type) {
        case 0U: 
#line 1639
        tmp___12 = string->len;
#line 1639
        (string->len) ++;
#line 1639
        *(string->jstring + tmp___12) = (char )'}';
#line 1640
        break;
        case 1U: 
#line 1642
        tmp___13 = string->len;
#line 1642
        (string->len) ++;
#line 1642
        *(string->jstring + tmp___13) = (char )']';
#line 1643
        break;
        default: 
#line 1645
        break;
        }
      }
    }
#line 1649
    if (free_tree) {
#line 1650
      jtmp = head->next;
#line 1651
      free((void *)head);
#line 1652
      head = jtmp;
    } else {
#line 1654
      head = head->next;
    }
  }
#line 1657
  *(string->jstring + string->len) = (char )'\000';
#line 1658
  return (string);
}
}
#line 1660 "tr.c"
static json_item *init_json_item(void) 
{ 
  json_item *jval ;
  json_item *tmp ;

  {
#line 1662
  tmp = (json_item *)xmalloc(sizeof(*jval));
#line 1662
  jval = tmp;
#line 1663
  jval->father = (struct _json_item *)((void *)0);
#line 1664
  jval->jchild.child = (struct _json_item *)((void *)0);
#line 1665
  jval->jchild.head = (struct _json_item *)((void *)0);
#line 1666
  jval->jchild.type = (json_child_t )3;
#line 1667
  jval->next = (struct _json_item *)((void *)0);
#line 1668
  jval->key.val = (char *)((void *)0);
#line 1669
  jval->key.len = (size_t )0;
#line 1670
  jval->jval.vu.str.value = (char *)((void *)0);
#line 1671
  jval->jval.vu.integer_value = (JSON_int_t )0;
#line 1672
  jval->jval.vu.float_value = 0.;
#line 1673
  jval->type = -1;
#line 1674
  return (jval);
}
}
#line 1676 "tr.c"
void free_json_item(json_item *cx ) 
{ 
  json_item *tcx ;

  {
#line 1678
  while ((unsigned long )cx != (unsigned long )((void *)0)) {
#line 1680
    if ((unsigned long )cx->key.val != (unsigned long )((void *)0)) {
#line 1681
      free((void *)cx->key.val);
    }
#line 1683
    if ((unsigned long )cx->jval.vu.str.value != (unsigned long )((void *)0)) {
#line 1684
      free((void *)cx->jval.vu.str.value);
    }
#line 1686
    if ((unsigned long )cx->jchild.child != (unsigned long )((void *)0)) {
#line 1687
      free_json_item(cx->jchild.child);
    }
#line 1689
    tcx = cx->next;
#line 1690
    free((void *)cx);
#line 1691
    cx = tcx;
  }
#line 1693
  return;
}
}
#line 1694 "tr.c"
json_item *json_item_copy(json_item *cx , json_item *father ) 
{ 
  json_item *new_item ;
  json_item *return_item ;
  json_item *temp_item ;

  {
#line 1696
  new_item = (json_item *)((void *)0);
#line 1696
  return_item = (json_item *)((void *)0);
#line 1697
  temp_item = (json_item *)((void *)0);
#line 1698
  while ((unsigned long )cx != (unsigned long )((void *)0)) {
#line 1699
    new_item = init_json_item();
#line 1700
    new_item->father = father;
#line 1701
    if ((unsigned long )return_item == (unsigned long )((void *)0)) {
#line 1702
      return_item = new_item;
    }
#line 1704
    new_item->type = cx->type;
#line 1705
    new_item->jchild.type = cx->jchild.type;
#line 1706
    if ((unsigned long )temp_item != (unsigned long )((void *)0)) {
#line 1707
      temp_item->next = new_item;
    }
#line 1709
    if ((unsigned long )cx->key.val != (unsigned long )((void *)0)) {
#line 1710
      new_item->key.len = cx->key.len;
#line 1711
      new_item->key.val = (char *)xmalloc(sizeof(char ) * (cx->key.len + 1UL));
#line 1712
      memcpy((void * __restrict  )new_item->key.val, (void const   * __restrict  )cx->key.val, cx->key.len + 1UL);
    }
#line 1714
    if ((unsigned long )cx->jval.vu.str.value != (unsigned long )((void *)0)) {
#line 1715
      new_item->jval.vu.str.length = cx->jval.vu.str.length;
#line 1716
      new_item->jval.vu.str.value = (char *)xmalloc(sizeof(char ) * (cx->jval.vu.str.length + 1UL));
#line 1717
      memcpy((void * __restrict  )new_item->jval.vu.str.value, (void const   * __restrict  )cx->jval.vu.str.value, cx->jval.vu.str.length + 1UL);
    } else
#line 1718
    if (cx->jval.vu.integer_value) {
#line 1719
      new_item->jval.vu.integer_value = cx->jval.vu.integer_value;
    } else
#line 1720
    if (cx->jval.vu.float_value) {
#line 1721
      new_item->jval.vu.float_value = cx->jval.vu.float_value;
    }
#line 1723
    if ((unsigned long )cx->jchild.child != (unsigned long )((void *)0)) {
#line 1724
      new_item->jchild.child = json_item_copy(cx->jchild.child, new_item);
    }
#line 1726
    if ((unsigned long )new_item->father != (unsigned long )((void *)0)) {
#line 1727
      (new_item->father)->jchild.head = new_item;
    }
#line 1729
    temp_item = new_item;
#line 1730
    cx = cx->next;
  }
#line 1732
  return (return_item);
}
}
#line 1734 "tr.c"
json_item *json_new_object(void) 
{ 
  json_item *obj ;
  json_item *tmp ;

  {
#line 1736
  tmp = init_json_item();
#line 1736
  obj = tmp;
#line 1737
  obj->jchild.type = (json_child_t )0;
#line 1738
  return (obj);
}
}
#line 1740 "tr.c"
json_item *json_new_array(void) 
{ 
  json_item *obj ;
  json_item *tmp ;

  {
#line 1742
  tmp = init_json_item();
#line 1742
  obj = tmp;
#line 1743
  obj->jchild.type = (json_child_t )1;
#line 1744
  return (obj);
}
}
#line 1746 "tr.c"
json_item *json_set_property_objN(json_item *obj , char const   *key , int keylen , json_item *value ) 
{ 
  json_item *new_item ;

  {
#line 1748
  new_item = value;
  {
#line 1750
  new_item->key.val = (char *)xmalloc(sizeof(char ) * (unsigned long )(keylen + 1));
#line 1751
  if ((int const   )*key != 0) {
#line 1752
    memcpy((void * __restrict  )new_item->key.val, (void const   * __restrict  )key, (size_t )(keylen + 1));
  } else {
#line 1754
    memset((void *)new_item->key.val, '\000', sizeof(char ) * (unsigned long )(keylen + 1));
  }
#line 1756
  new_item->key.len = (size_t )keylen;
  }
#line 1758
  new_item->father = obj;
#line 1759
  if ((unsigned long )obj->jchild.child == (unsigned long )((void *)0)) {
#line 1760
    obj->jchild.child = new_item;
  } else {
#line 1762
    (obj->jchild.head)->next = new_item;
  }
#line 1764
  obj->jchild.head = new_item;
#line 1765
  return (new_item);
}
}
#line 1767 "tr.c"
void json_set_property_objZ(json_item *obj , char const   *key , json_item *value ) 
{ 
  size_t tmp ;

  {
#line 1769
  tmp = strlen(key);
#line 1769
  json_set_property_objN(obj, key, (int )tmp, value);
#line 1770
  return;
}
}
#line 1771 "tr.c"
json_item *json_set_property_intN(json_item *obj , char const   *key , int keylen , JSON_int_t value ) 
{ 
  json_item *new_item ;
  json_item *tmp ;

  {
#line 1773
  tmp = init_json_item();
#line 1773
  new_item = tmp;
  {
#line 1775
  new_item->key.val = (char *)xmalloc(sizeof(char ) * (unsigned long )(keylen + 1));
#line 1776
  if ((int const   )*key != 0) {
#line 1777
    memcpy((void * __restrict  )new_item->key.val, (void const   * __restrict  )key, (size_t )(keylen + 1));
  } else {
#line 1779
    memset((void *)new_item->key.val, '\000', (size_t )(keylen + 1));
  }
#line 1781
  new_item->key.len = (size_t )keylen;
  }
#line 1783
  new_item->father = obj;
#line 1784
  new_item->jval.vu.integer_value = value;
#line 1785
  new_item->type = 5;
#line 1786
  if ((unsigned long )obj->jchild.child == (unsigned long )((void *)0)) {
#line 1787
    obj->jchild.child = new_item;
  } else {
#line 1789
    (obj->jchild.head)->next = new_item;
  }
#line 1791
  obj->jchild.head = new_item;
#line 1792
  return (new_item);
}
}
#line 1794 "tr.c"
void json_set_property_intZ(json_item *obj , char const   *key , JSON_int_t value ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1796
  if ((unsigned long )key != (unsigned long )((void *)0)) {
#line 1796
    tmp = strlen(key);
#line 1796
    tmp___0 = tmp;
  } else {
#line 1796
    tmp___0 = (size_t )0;
  }
#line 1796
  len = (int )tmp___0;
#line 1797
  json_set_property_intN(obj, key, len, value);
#line 1798
  return;
}
}
#line 1799 "tr.c"
json_item *json_set_property_floatN(json_item *obj , char const   *key , int keylen , long double value ) 
{ 
  json_item *new_item ;
  json_item *tmp ;

  {
#line 1801
  tmp = init_json_item();
#line 1801
  new_item = tmp;
  {
#line 1803
  new_item->key.val = (char *)xmalloc(sizeof(char ) * (unsigned long )(keylen + 1));
#line 1804
  if ((int const   )*key != 0) {
#line 1805
    memcpy((void * __restrict  )new_item->key.val, (void const   * __restrict  )key, (size_t )(keylen + 1));
  } else {
#line 1807
    memset((void *)new_item->key.val, '\000', (size_t )(keylen + 1));
  }
#line 1809
  new_item->key.len = (size_t )keylen;
  }
#line 1811
  new_item->father = obj;
#line 1812
  new_item->jval.vu.float_value = (double )value;
#line 1813
  new_item->type = 6;
#line 1814
  if ((unsigned long )obj->jchild.child == (unsigned long )((void *)0)) {
#line 1815
    obj->jchild.child = new_item;
  } else {
#line 1817
    (obj->jchild.head)->next = new_item;
  }
#line 1819
  obj->jchild.head = new_item;
#line 1820
  return (new_item);
}
}
#line 1822 "tr.c"
json_item *json_set_property_boolean(json_item *obj , char const   *key , int keylen , int value ) 
{ 
  json_item *new_item ;
  json_item *tmp ;

  {
#line 1824
  tmp = init_json_item();
#line 1824
  new_item = tmp;
  {
#line 1826
  new_item->key.val = (char *)xmalloc(sizeof(char ) * (unsigned long )(keylen + 1));
#line 1827
  if ((int const   )*key != 0) {
#line 1828
    memcpy((void * __restrict  )new_item->key.val, (void const   * __restrict  )key, (size_t )(keylen + 1));
  } else {
#line 1830
    memset((void *)new_item->key.val, '\000', (size_t )(keylen + 1));
  }
#line 1832
  new_item->key.len = (size_t )keylen;
  }
#line 1834
  new_item->father = obj;
#line 1835
  if (value) {
#line 1836
    new_item->type = 8;
  } else {
#line 1838
    new_item->type = 9;
  }
#line 1839
  if ((unsigned long )obj->jchild.child == (unsigned long )((void *)0)) {
#line 1840
    obj->jchild.child = new_item;
  } else {
#line 1842
    (obj->jchild.head)->next = new_item;
  }
#line 1844
  obj->jchild.head = new_item;
#line 1845
  return (new_item);
}
}
#line 1847 "tr.c"
json_item *json_set_property_null(json_item *obj , char const   *key , int keylen ) 
{ 
  json_item *new_item ;
  json_item *tmp ;

  {
#line 1849
  tmp = init_json_item();
#line 1849
  new_item = tmp;
  {
#line 1851
  new_item->key.val = (char *)xmalloc(sizeof(char ) * (unsigned long )(keylen + 1));
#line 1852
  if ((int const   )*key != 0) {
#line 1853
    memcpy((void * __restrict  )new_item->key.val, (void const   * __restrict  )key, (size_t )(keylen + 1));
  } else {
#line 1855
    memset((void *)new_item->key.val, '\000', sizeof(char ) * (unsigned long )(keylen + 1));
  }
#line 1857
  new_item->key.len = (size_t )keylen;
  }
#line 1859
  new_item->father = obj;
#line 1860
  new_item->type = 7;
#line 1861
  if ((unsigned long )obj->jchild.child == (unsigned long )((void *)0)) {
#line 1862
    obj->jchild.child = new_item;
  } else {
#line 1864
    (obj->jchild.head)->next = new_item;
  }
#line 1866
  obj->jchild.head = new_item;
#line 1867
  return (new_item);
}
}
#line 1869 "tr.c"
json_item *json_set_property_strN(json_item *obj , char const   *key , int keylen , char const   *value , int valuelen ) 
{ 
  json_item *new_item ;
  json_item *tmp ;

  {
#line 1871
  tmp = init_json_item();
#line 1871
  new_item = tmp;
  {
#line 1873
  new_item->key.val = (char *)xmalloc(sizeof(char ) * (unsigned long )(keylen + 1));
#line 1874
  if ((int const   )*key != 0) {
#line 1875
    memcpy((void * __restrict  )new_item->key.val, (void const   * __restrict  )key, (size_t )(keylen + 1));
  } else {
#line 1877
    memset((void *)new_item->key.val, '\000', sizeof(char ) * (unsigned long )(keylen + 1));
  }
#line 1879
  new_item->key.len = (size_t )keylen;
  }
#line 1881
  new_item->jval.vu.str.value = (char *)xmalloc(sizeof(char ) * (unsigned long )(valuelen + 1));
#line 1882
  if ((int const   )*value != 0) {
#line 1883
    memcpy((void * __restrict  )new_item->jval.vu.str.value, (void const   * __restrict  )value, (size_t )(valuelen + 1));
  } else {
#line 1885
    memset((void *)new_item->jval.vu.str.value, '\000', (size_t )(valuelen + 1));
  }
#line 1887
  new_item->jval.vu.str.length = (size_t )valuelen;
#line 1888
  new_item->type = 10;
#line 1889
  new_item->father = obj;
#line 1890
  if ((unsigned long )obj->jchild.child == (unsigned long )((void *)0)) {
#line 1891
    obj->jchild.child = new_item;
  } else {
#line 1893
    (obj->jchild.head)->next = new_item;
  }
#line 1895
  obj->jchild.head = new_item;
#line 1896
  return (new_item);
}
}
#line 1898 "tr.c"
void json_set_property_strZ(json_item *obj , char const   *key , char const   *value ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1900
  if ((unsigned long )key != (unsigned long )((void *)0)) {
#line 1900
    tmp = strlen(key);
#line 1900
    tmp___0 = tmp;
  } else {
#line 1900
    tmp___0 = (size_t )0;
  }
#line 1900
  len = (int )tmp___0;
#line 1901
  tmp___1 = strlen(value);
#line 1901
  json_set_property_strN(obj, key, len, value, (int )tmp___1);
#line 1902
  return;
}
}
#line 1903 "tr.c"
json_item *json_set_element_strN(json_item *obj , char const   *value , int valuelen ) 
{ 
  json_item *tmp ;

  {
#line 1905
  tmp = json_set_property_strN(obj, (char const   *)((void *)0), 0, value, valuelen);
#line 1905
  return (tmp);
}
}
#line 1907 "tr.c"
void json_set_element_strZ(json_item *obj , char const   *value ) 
{ 


  {
#line 1909
  json_set_property_strZ(obj, (char const   *)((void *)0), value);
#line 1910
  return;
}
}
#line 1911 "tr.c"
void json_set_element_obj(json_item *obj , json_item *value ) 
{ 


  {
#line 1913
  json_set_property_objN(obj, (char const   *)((void *)0), 0, value);
#line 1914
  return;
}
}
#line 1915 "tr.c"
void json_set_element_int(json_item *obj , long value ) 
{ 


  {
#line 1917
  json_set_property_intN(obj, (char const   *)((void *)0), 0, (JSON_int_t )value);
#line 1918
  return;
}
}
#line 1919 "tr.c"
void json_set_element_float(json_item *obj , long double value ) 
{ 


  {
#line 1921
  json_set_property_floatN(obj, (char const   *)((void *)0), 0, value);
#line 1922
  return;
}
}
#line 1923 "tr.c"
void json_set_element_boolean(json_item *obj , int value ) 
{ 


  {
#line 1925
  json_set_property_boolean(obj, (char const   *)((void *)0), 0, value);
#line 1926
  return;
}
}
#line 1927 "tr.c"
void json_set_element_null(json_item *obj ) 
{ 


  {
#line 1929
  json_set_property_null(obj, (char const   *)((void *)0), 0);
#line 1930
  return;
}
}
#line 1931 "tr.c"
void json_merge(json_item *obj_out , json_item *obj_in ) 
{ 


  {
#line 1933
  return;
}
}
#line 1934 "tr.c"
static int json_callback(void *ctx , int type , JSON_value const   *value ) 
{ 
  json_context *cx ;
  json_item *jval ;

  {
#line 1936
  cx = (json_context *)ctx;
#line 1937
  jval = (json_item *)((void *)0);
#line 1938
  switch (type) {
  case 1: 
  case 3: 
#line 1941
  if (! cx->key_under) {
#line 1942
    jval = init_json_item();
#line 1943
    if ((unsigned long )cx->current_cx != (unsigned long )((void *)0)) {
#line 1944
      if (cx->start_depth) {
#line 1945
        (cx->current_cx)->jchild.child = jval;
#line 1946
        jval->father = cx->current_cx;
      } else {
#line 1948
        jval->father = (cx->current_cx)->father;
#line 1949
        (cx->current_cx)->next = jval;
      }
    }
#line 1952
    cx->current_cx = jval;
  }
#line 1954
  if (type == 3) {
#line 1954
    (cx->current_cx)->jchild.type = (json_child_t )0;
  } else {
#line 1954
    (cx->current_cx)->jchild.type = (json_child_t )1;
  }
#line 1955
  cx->start_depth = 1;
#line 1956
  cx->key_under = 0;
#line 1957
  break;
  case 2: 
  case 4: 
#line 1960
  if ((unsigned long )(cx->current_cx)->father != (unsigned long )((void *)0)) {
#line 1960
    if (! cx->start_depth) {
#line 1961
      cx->current_cx = (cx->current_cx)->father;
    }
  }
#line 1963
  cx->start_depth = 0;
#line 1964
  cx->key_under = 0;
#line 1965
  break;
  case 11: 
#line 1967
  jval = init_json_item();
#line 1968
  if (cx->start_depth) {
#line 1969
    (cx->current_cx)->jchild.child = jval;
#line 1970
    jval->father = cx->current_cx;
#line 1971
    cx->start_depth = 0;
  } else {
#line 1973
    jval->father = (cx->current_cx)->father;
#line 1974
    (cx->current_cx)->next = jval;
  }
#line 1976
  cx->current_cx = jval;
#line 1977
  cx->key_under = 1;
#line 1978
  (cx->current_cx)->key.val = (char *)xmalloc(sizeof(char ) * (unsigned long )(value->vu.str.length + 1UL));
#line 1979
  memcpy((void * __restrict  )(cx->current_cx)->key.val, (void const   * __restrict  )value->vu.str.value, (size_t )(value->vu.str.length + 1UL));
#line 1980
  (cx->current_cx)->key.len = (size_t )value->vu.str.length;
#line 1981
  break;
  case 10: 
  case 9: 
  case 8: 
  case 7: 
  case 6: 
  case 5: 
#line 1988
  if (! cx->key_under) {
#line 1989
    jval = init_json_item();
#line 1990
    if (cx->start_depth) {
#line 1991
      (cx->current_cx)->jchild.child = jval;
#line 1992
      jval->father = cx->current_cx;
#line 1993
      cx->start_depth = 0;
    } else {
#line 1995
      jval->father = (cx->current_cx)->father;
#line 1996
      (cx->current_cx)->next = jval;
    }
#line 1998
    cx->current_cx = jval;
  }
#line 2000
  cx->key_under = 0;
#line 2001
  switch (type) {
  case 5: 
#line 2003
  (cx->current_cx)->jval.vu.integer_value = (JSON_int_t )value->vu.integer_value;
#line 2004
  break;
  case 6: 
#line 2006
  (cx->current_cx)->jval.vu.float_value = (double )value->vu.float_value;
#line 2007
  break;
  case 9: 
  case 7: 
#line 2010
  (cx->current_cx)->jval.vu.integer_value = (JSON_int_t )0;
#line 2011
  break;
  case 8: 
#line 2013
  (cx->current_cx)->jval.vu.integer_value = (JSON_int_t )1;
#line 2014
  break;
  case 10: 
#line 2016
  (cx->current_cx)->jval.vu.str.value = (char *)xmalloc(sizeof(char ) * (unsigned long )(value->vu.str.length + 1UL));
#line 2017
  memcpy((void * __restrict  )(cx->current_cx)->jval.vu.str.value, (void const   * __restrict  )value->vu.str.value, (size_t )(value->vu.str.length + 1UL));
#line 2018
  (cx->current_cx)->jval.vu.str.length = (size_t )value->vu.str.length;
#line 2019
  break;
  }
#line 2021
  (cx->current_cx)->type = type;
#line 2022
  break;
  default: 
#line 2024
  break;
  }
#line 2026
  if ((unsigned long )cx->head == (unsigned long )((void *)0)) {
#line 2026
    if ((unsigned long )cx->current_cx != (unsigned long )((void *)0)) {
#line 2027
      cx->head = cx->current_cx;
    }
  }
#line 2029
  return (1);
}
}
#line 2031 "tr.c"
json_item *init_json_parser(char const   *json_string ) 
{ 
  char const   *pRaw ;
  JSON_config config ;
  struct JSON_parser_struct *jc ;
  json_context jcx ;
  int tmp ;
  int tmp___0 ;

  {
#line 2035
  jc = (struct JSON_parser_struct *)((void *)0);
#line 2036
  jcx.key_under = 0;
#line 2036
  jcx.start_depth = 0;
#line 2036
  jcx.head = (json_item *)((void *)0);
#line 2036
  jcx.current_cx = (json_item *)((void *)0);
#line 2037
  init_JSON_config(& config);
#line 2038
  config.depth = 15;
#line 2039
  config.callback = & json_callback;
#line 2040
  config.callback_ctx = (void *)(& jcx);
#line 2041
  config.allow_comments = 0;
#line 2042
  config.handle_floats_manually = 0;
#line 2043
  jc = new_JSON_parser((JSON_config const   *)(& config));
#line 2044
  pRaw = json_string;
#line 2044
  while ((unsigned char )*pRaw) {
#line 2045
    tmp = JSON_parser_char(jc, (int )*pRaw);
#line 2045
    if (! tmp) {
#line 2046
      free_json_item(jcx.head);
#line 2047
      delete_JSON_parser(jc);
#line 2048
      return ((json_item *)((void *)0));
    }
#line 2044
    pRaw ++;
  }
#line 2051
  tmp___0 = JSON_parser_done(jc);
#line 2051
  if (! tmp___0) {
#line 2052
    free_json_item(jcx.head);
#line 2053
    delete_JSON_parser(jc);
#line 2054
    return ((json_item *)((void *)0));
  }
#line 2056
  delete_JSON_parser(jc);
#line 2057
  return (jcx.head);
}
}
#line 2059 "tr.c"
void json_aff(json_item *cx , int depth ) 
{ 


  {
#line 2061
  while ((unsigned long )cx != (unsigned long )((void *)0)) {
#line 2062
    if ((unsigned long )cx->key.val != (unsigned long )((void *)0)) {
#line 2063
      printf((char const   * __restrict  )"Key %s\n", cx->key.val);
    }
#line 2065
    if ((unsigned long )cx->jval.vu.str.value != (unsigned long )((void *)0)) {
#line 2066
      printf((char const   * __restrict  )"Value : %s\n", cx->jval.vu.str.value);
    }
#line 2068
    if (depth) {
#line 2068
      if ((unsigned long )cx->jchild.child != (unsigned long )((void *)0)) {
#line 2069
        json_aff(cx->jchild.child, depth - 1);
      }
    }
#line 2071
    cx = cx->next;
  }
#line 2073
  return;
}
}
#line 2074 "tr.c"
json_item *json_lookup(json_item *head , char *path ) 
{ 
  char *split[16] ;
  char *base ;
  size_t nTok ;
  int i ;
  struct _json_item *tmp ;
  int tmp___0 ;

  {
#line 2079
  i = 0;
#line 2080
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 2081
    return ((json_item *)((void *)0));
  } else
#line 2080
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 2081
    return ((json_item *)((void *)0));
  }
#line 2083
  base = xstrdup((char const   *)path);
#line 2084
  nTok = explode((char const   )'.', base, split, 15U);
#line 2085
  while (1) {
#line 2085
    if ((unsigned long )head != (unsigned long )((void *)0)) {
#line 2085
      if (! ((size_t )i <= nTok)) {
#line 2085
        break;
      }
    } else {
#line 2085
      break;
    }
#line 2086
    if ((unsigned long )head->key.val != (unsigned long )((void *)0)) {
#line 2086
      tmp___0 = strcasecmp((char const   *)split[i], (char const   *)head->key.val);
#line 2086
      if (tmp___0 == 0) {
#line 2087
        if ((size_t )i == nTok) {
#line 2088
          free((void *)base);
#line 2089
          if ((unsigned long )head->jchild.child != (unsigned long )((void *)0)) {
#line 2089
            tmp = head->jchild.child;
          } else {
#line 2089
            tmp = head;
          }
#line 2089
          return (tmp);
        }
#line 2091
        i ++;
#line 2092
        head = head->jchild.child;
#line 2093
        continue;
      }
    }
#line 2095
    head = head->next;
  }
#line 2097
  free((void *)base);
#line 2098
  return ((json_item *)((void *)0));
}
}
