/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 4 "tr.c"
typedef unsigned long size_t;
#line 34 "tr.c"
typedef long __time_t;
#line 54 "tr.c"
typedef unsigned int __socklen_t;
#line 60 "tr.c"
typedef __time_t time_t;
#line 989 "tr.c"
typedef __socklen_t socklen_t;
#line 1498
struct _htbl_item ;
#line 1498 "tr.c"
struct HTBL {
   struct _htbl_item *first ;
   struct _htbl_item **table ;
};
#line 1498 "tr.c"
typedef struct HTBL HTBL;
#line 1503 "tr.c"
struct _htbl_item {
   char *key ;
   void *addrs ;
   struct _htbl_item *next ;
   struct _htbl_item *lnext ;
   struct _htbl_item *lprev ;
};
#line 1517 "tr.c"
struct __anonstruct_left_936791725 {
   char *val ;
   int len ;
};
#line 1517 "tr.c"
struct __anonstruct_right_936791726 {
   char *val ;
   int len ;
};
#line 1517 "tr.c"
struct __anonstruct_padding_387678234 {
   struct __anonstruct_left_936791725 left ;
   struct __anonstruct_right_936791726 right ;
};
#line 1517 "tr.c"
struct _transport_properties {
   struct __anonstruct_padding_387678234 padding ;
};
#line 1529 "tr.c"
struct __anonstruct_jsonp_728269610 {
   struct _transport_properties properties ;
};
#line 1529 "tr.c"
struct __anonstruct_xhrstreaming_728269611 {
   struct _transport_properties properties ;
};
#line 1529 "tr.c"
struct __anonstruct_sse_728269612 {
   struct _transport_properties properties ;
};
#line 1529 "tr.c"
struct __anonstruct_websocket_728269613 {
   struct _transport_properties properties ;
};
#line 1529 "tr.c"
struct __anonstruct_websocket_ietf_728269614 {
   struct _transport_properties properties ;
};
#line 1529 "tr.c"
struct _ape_transports {
   struct __anonstruct_jsonp_728269610 jsonp ;
   struct __anonstruct_xhrstreaming_728269611 xhrstreaming ;
   struct __anonstruct_sse_728269612 sse ;
   struct __anonstruct_websocket_728269613 websocket ;
   struct __anonstruct_websocket_ietf_728269614 websocket_ietf ;
};
#line 1546
struct _http_state ;
#line 1547
struct _http_header_line ;
#line 1547 "tr.c"
struct _http_state {
   struct _http_header_line *hlines ;
   char *uri ;
   void *buffer_addr ;
   char const   *data ;
   char const   *host ;
   int pos ;
   int contentlength ;
   int read ;
   unsigned short step ;
   unsigned short type ;
   unsigned short error ;
};
#line 1561
enum __anonenum_ws_version_108903720 {
    WS_OLD = 0,
    WS_76 = 1,
    WS_IETF_06 = 2,
    WS_IETF_07 = 3
} ;
#line 1561 "tr.c"
typedef enum __anonenum_ws_version_108903720 ws_version;
#line 1567
enum __anonenum_ws_payload_step_623117124 {
    WS_STEP_KEY = 0,
    WS_STEP_START = 1,
    WS_STEP_LENGTH = 2,
    WS_STEP_SHORT_LENGTH = 3,
    WS_STEP_EXTENDED_LENGTH = 4,
    WS_STEP_DATA = 5,
    WS_STEP_END = 6
} ;
#line 1567 "tr.c"
typedef enum __anonenum_ws_payload_step_623117124 ws_payload_step;
#line 1576 "tr.c"
struct __anonstruct_key_852451852 {
   unsigned char val[4] ;
   int pos ;
};
#line 1576 "tr.c"
union __anonunion____missing_field_name_651569011 {
   unsigned short short_length ;
   unsigned long long extended_length ;
};
#line 1576 "tr.c"
struct __anonstruct_frame_payload_25740215 {
   unsigned char start ;
   unsigned char length ;
   union __anonunion____missing_field_name_651569011 __annonCompField1 ;
};
#line 1576 "tr.c"
struct _websocket_state {
   struct _http_state *http ;
   char const   *data ;
   unsigned int offset ;
   unsigned short error ;
   ws_version version ;
   struct __anonstruct_key_852451852 key ;
   struct __anonstruct_frame_payload_25740215 frame_payload ;
   ws_payload_step step ;
   int data_pos ;
   int data_inkey ;
   int frame_pos ;
};
#line 1576 "tr.c"
typedef struct _websocket_state websocket_state;
#line 1602
enum __anonenum_ape_socket_t_437855647 {
    STREAM_IN = 0,
    STREAM_OUT = 1,
    STREAM_SERVER = 2,
    STREAM_DELEGATE = 3
} ;
#line 1602 "tr.c"
typedef enum __anonenum_ape_socket_t_437855647 ape_socket_t;
#line 1608
enum __anonenum_ape_socket_state_t_355527677 {
    STREAM_ONLINE = 0,
    STREAM_PROGRESS = 1
} ;
#line 1608 "tr.c"
typedef enum __anonenum_ape_socket_state_t_355527677 ape_socket_state_t;
#line 1612
struct _ape_buffer ;
#line 1612 "tr.c"
typedef struct _ape_buffer ape_buffer;
#line 1613 "tr.c"
struct _ape_buffer {
   char *data ;
   void *slot ;
   unsigned int size ;
   unsigned int length ;
   int islot ;
};
#line 1620
struct _callback_hook ;
#line 1620 "tr.c"
struct __anonstruct_cmd_hook_247173628 {
   struct _callback_hook *head ;
   struct _callback_hook *foot ;
};
#line 1620
struct _ape_proxy ;
#line 1620
struct _ape_proxy_cache ;
#line 1620 "tr.c"
struct __anonstruct_proxy_610188502 {
   struct _ape_proxy *list ;
   struct _ape_proxy_cache *hosts ;
};
#line 1620
struct _ticks_callback ;
#line 1620 "tr.c"
struct __anonstruct_timers_358416453 {
   struct _ticks_callback *timers ;
   unsigned int ntimers ;
};
#line 1620 "tr.c"
struct __anonstruct_logs_649416129 {
   unsigned int lvl ;
   unsigned int use_syslog ;
   int fd ;
};
#line 1620
struct apeconfig ;
#line 1620
struct USERS ;
#line 1620
struct _socks_bufout ;
#line 1620
struct _ace_plugins ;
#line 1620
struct _fdevent ;
#line 1620
struct _ape_socket ;
#line 1620
struct _extend ;
#line 1620 "tr.c"
struct _acetables {
   struct __anonstruct_cmd_hook_247173628 cmd_hook ;
   struct __anonstruct_proxy_610188502 proxy ;
   struct __anonstruct_timers_358416453 timers ;
   struct __anonstruct_logs_649416129 logs ;
   struct _ape_transports transports ;
   HTBL *hLogin ;
   HTBL *hSessid ;
   HTBL *hLusers ;
   HTBL *hCallback ;
   HTBL *hPubid ;
   struct apeconfig *srv ;
   struct _callback_hook *bad_cmd_callbacks ;
   struct USERS *uHead ;
   struct _socks_bufout *bufout ;
   struct _ace_plugins *plugins ;
   struct _fdevent *events ;
   struct _ape_socket **co ;
   struct _extend *properties ;
   char const   *confs_path ;
   int is_daemon ;
   int basemem ;
   unsigned int nConnected ;
};
#line 1620 "tr.c"
typedef struct _acetables acetables;
#line 1658
struct _ape_parser ;
#line 1658 "tr.c"
typedef struct _ape_parser ape_parser;
#line 1659 "tr.c"
struct _ape_parser {
   void (*parser_func)(struct _ape_socket * , acetables * ) ;
   void (*destroy)(struct _ape_parser * ) ;
   void (*onready)(struct _ape_parser * , acetables * ) ;
   void *data ;
   struct _ape_socket *socket ;
   short ready ;
};
#line 1667 "tr.c"
typedef struct _ape_socket ape_socket;
#line 1668 "tr.c"
struct __anonstruct_callbacks_414146993 {
   void (*on_accept)(struct _ape_socket *client , acetables *g_ape ) ;
   void (*on_connect)(struct _ape_socket *client , acetables *g_ape ) ;
   void (*on_disconnect)(struct _ape_socket *client , acetables *g_ape ) ;
   void (*on_read)(struct _ape_socket *client , struct _ape_buffer *buf , size_t offset , acetables *g_ape ) ;
   void (*on_read_lf)(struct _ape_socket *client , char *data , acetables *g_ape ) ;
   void (*on_data_completly_sent)(struct _ape_socket *client , acetables *g_ape ) ;
   void (*on_write)(struct _ape_socket *client , acetables *g_ape ) ;
};
#line 1668 "tr.c"
struct _ape_socket {
   struct __anonstruct_callbacks_414146993 callbacks ;
   ape_parser parser ;
   ape_buffer buffer_in ;
   char ip_client[16] ;
   long idle ;
   void *attach ;
   void *data ;
   int fd ;
   int burn_after_writing ;
   ape_socket_state_t state ;
   ape_socket_t stream_type ;
};
#line 1690 "tr.c"
typedef long long JSON_int_t;
#line 1721 "tr.c"
struct __anonstruct_str_653462436 {
   char *value ;
   size_t length ;
};
#line 1721 "tr.c"
struct __anonstruct_vu_972442087 {
   JSON_int_t integer_value ;
   double float_value ;
   struct __anonstruct_str_653462436 str ;
};
#line 1721 "tr.c"
struct JSON_value_struct {
   struct __anonstruct_vu_972442087 vu ;
};
#line 1776 "tr.c"
struct jsontring {
   char *jstring ;
   size_t jsize ;
   size_t len ;
};
#line 1781
enum __anonenum_json_child_t_34874264 {
    JSON_C_T_OBJ = 0,
    JSON_C_T_ARR = 1,
    JSON_C_T_VAL = 2,
    JSON_C_T_NULL = 3
} ;
#line 1781 "tr.c"
typedef enum __anonenum_json_child_t_34874264 json_child_t;
#line 1787 "tr.c"
struct __anonstruct_jchild_579492347 {
   struct _json_item *child ;
   struct _json_item *head ;
   json_child_t type ;
};
#line 1787 "tr.c"
struct __anonstruct_key_961283316 {
   char *val ;
   size_t len ;
};
#line 1787 "tr.c"
struct _json_item {
   struct JSON_value_struct jval ;
   struct __anonstruct_jchild_579492347 jchild ;
   struct __anonstruct_key_961283316 key ;
   struct _json_item *father ;
   struct _json_item *next ;
   int type ;
};
#line 1787 "tr.c"
typedef struct _json_item json_item;
#line 1843
struct _pipe_link ;
#line 1844
struct _transpipe ;
#line 1844 "tr.c"
struct _pipe_link {
   struct _transpipe *plink ;
   struct _pipe_link *next ;
   void (*on_unlink)(struct _transpipe * , struct _transpipe * , acetables * ) ;
};
#line 1849 "tr.c"
typedef struct _transpipe transpipe;
#line 1850 "tr.c"
struct _transpipe {
   void *pipe ;
   void *data ;
   struct _pipe_link *link ;
   struct _extend *properties ;
   void (*on_send)(struct _transpipe * , struct USERS * , json_item * , acetables * ) ;
   int type ;
   char pubid[33] ;
};
#line 1870
enum __anonenum_EXTEND_TYPE_543230818 {
    EXTEND_STR = 0,
    EXTEND_JSON = 1,
    EXTEND_POINTER = 2
} ;
#line 1870 "tr.c"
typedef enum __anonenum_EXTEND_TYPE_543230818 EXTEND_TYPE;
#line 1875
enum __anonenum_EXTEND_PUBLIC_280177277 {
    EXTEND_ISPUBLIC = 0,
    EXTEND_ISPRIVATE = 1
} ;
#line 1875 "tr.c"
typedef enum __anonenum_EXTEND_PUBLIC_280177277 EXTEND_PUBLIC;
#line 1879 "tr.c"
typedef struct _extend extend;
#line 1880 "tr.c"
struct _extend {
   void *val ;
   EXTEND_TYPE type ;
   EXTEND_PUBLIC visibility ;
   struct _extend *next ;
   char key[33] ;
};
#line 1892
struct userslist ;
#line 1892
struct BANNED ;
#line 1892 "tr.c"
struct CHANNEL {
   struct _transpipe *pipe ;
   struct userslist *head ;
   struct BANNED *banned ;
   extend *properties ;
   int flags ;
   char name[41] ;
};
#line 1892 "tr.c"
typedef struct CHANNEL CHANNEL;
#line 1901 "tr.c"
struct BANNED {
   char ip[16] ;
   char reason[257] ;
   long expire ;
   struct BANNED *next ;
};
#line 1925
struct RAW ;
#line 1925 "tr.c"
struct _raw_pool {
   struct RAW *raw ;
   struct _raw_pool *next ;
   struct _raw_pool *prev ;
   int start ;
};
#line 1931
struct _link_list ;
#line 1931 "tr.c"
struct __anonstruct_links_822520370 {
   struct _link_list *ulink ;
   int nlink ;
};
#line 1931
struct _session ;
#line 1931 "tr.c"
struct __anonstruct_sessions_574361247 {
   struct _session *data ;
   int length ;
};
#line 1931
struct CHANLIST ;
#line 1931
struct _subuser ;
#line 1931 "tr.c"
struct USERS {
   struct __anonstruct_links_822520370 links ;
   struct __anonstruct_sessions_574361247 sessions ;
   struct USERS *next ;
   struct USERS *prev ;
   struct CHANLIST *chan_foot ;
   struct _transpipe *pipe ;
   struct _extend *properties ;
   struct _subuser *subuser ;
   json_item *cmdqueue ;
   time_t idle ;
   int transport ;
   int nsub ;
   unsigned int nraw ;
   unsigned int flags ;
   unsigned short type ;
   unsigned short istmp ;
   char ip[16] ;
   char lastping[24] ;
   char sessid[33] ;
};
#line 1931 "tr.c"
typedef struct USERS USERS;
#line 1959 "tr.c"
struct _raw_pool_user {
   int nraw ;
   int size ;
   struct _raw_pool *rawhead ;
   struct _raw_pool *rawfoot ;
};
#line 1965 "tr.c"
typedef struct _subuser subuser;
#line 1966 "tr.c"
struct __anonstruct_raw_pools_1003203111 {
   struct _raw_pool_user low ;
   struct _raw_pool_user high ;
   int nraw ;
};
#line 1966
struct _http_headers_response ;
#line 1966 "tr.c"
struct __anonstruct_headers_289187151 {
   struct _http_headers_response *content ;
   int sent ;
};
#line 1966 "tr.c"
struct _subuser {
   struct __anonstruct_raw_pools_1003203111 raw_pools ;
   struct __anonstruct_headers_289187151 headers ;
   struct _extend *properties ;
   struct _subuser *next ;
   ape_socket *client ;
   USERS *user ;
   time_t idle ;
   int state ;
   int need_update ;
   int wait_for_free ;
   int nraw ;
   int burn_after_writing ;
   int current_chl ;
   char channel[257] ;
};
#line 1990 "tr.c"
struct CHANLIST {
   struct CHANNEL *chaninfo ;
   struct CHANLIST *next ;
};
#line 1995 "tr.c"
struct _users_link {
   USERS *a ;
   USERS *b ;
   int link_type ;
};
#line 2001 "tr.c"
struct _link_list {
   struct _users_link *link ;
   struct _link_list *next ;
};
#line 2006 "tr.c"
struct userslist {
   struct USERS *userinfo ;
   struct userslist *next ;
   unsigned int level ;
};
#line 2006 "tr.c"
typedef struct userslist userslist;
#line 2013 "tr.c"
struct _session {
   char *val ;
   struct _session *next ;
   char key[33] ;
};
#line 2067 "tr.c"
struct __anonstruct_key_1003203112 {
   char val[32] ;
   int len ;
};
#line 2067 "tr.c"
struct __anonstruct_value_1003203113 {
   char *val ;
   int len ;
};
#line 2067 "tr.c"
struct _http_headers_fields {
   struct __anonstruct_key_1003203112 key ;
   struct __anonstruct_value_1003203113 value ;
   struct _http_headers_fields *next ;
};
#line 2079 "tr.c"
typedef struct _http_headers_response http_headers_response;
#line 2080 "tr.c"
struct __anonstruct_detail_1003203114 {
   char val[64] ;
   int len ;
};
#line 2080 "tr.c"
struct _http_headers_response {
   int code ;
   struct __anonstruct_detail_1003203114 detail ;
   struct _http_headers_fields *fields ;
   struct _http_headers_fields *last ;
};
#line 2097 "tr.c"
struct __anonstruct_key_178901730 {
   char val[64] ;
   unsigned int len ;
};
#line 2097 "tr.c"
struct __anonstruct_value_178901731 {
   char val[1024] ;
   unsigned int len ;
};
#line 2097 "tr.c"
struct _http_header_line {
   struct __anonstruct_key_178901730 key ;
   struct __anonstruct_value_178901731 value ;
   struct _http_header_line *next ;
};
#line 2118 "tr.c"
typedef unsigned short uint16_t;
#line 2119 "tr.c"
typedef unsigned int uint32_t;
#line 2981 "tr.c"
struct _socks_bufout {
   char *buf ;
   int fd ;
   int buflen ;
   int allocsize ;
};
#line 3007
struct _ape_proxy_pipe ;
#line 3007 "tr.c"
typedef struct _ape_proxy_pipe ape_proxy_pipe;
#line 3008 "tr.c"
struct _ape_proxy_pipe {
   int allow_write ;
   char pipe[33] ;
   struct _ape_proxy_pipe *next ;
};
#line 3014 "tr.c"
typedef struct _ape_proxy ape_proxy;
#line 3015 "tr.c"
struct __anonstruct_sock_907996845 {
   struct _ape_proxy_cache *host ;
   int port ;
   int fd ;
};
#line 3015 "tr.c"
struct _ape_proxy {
   char identifier[33] ;
   int eol ;
   struct _transpipe *pipe ;
   struct __anonstruct_sock_907996845 sock ;
   int state ;
   int nlink ;
   ape_proxy_pipe *to ;
   struct _ape_proxy *next ;
   struct _ape_proxy *prev ;
   struct _extend *properties ;
};
#line 3033 "tr.c"
struct _ape_proxy_cache {
   char *host ;
   char ip[16] ;
   struct _ape_proxy_cache *next ;
};
#line 3068
enum __anonenum_transport_t_673335178 {
    TRANSPORT_LONGPOLLING = 0,
    TRANSPORT_XHRSTREAMING = 1,
    TRANSPORT_JSONP = 2,
    TRANSPORT_PERSISTANT = 3,
    TRANSPORT_SSE_LONGPOLLING = 4,
    TRANSPORT_SSE_JSONP = 5,
    TRANSPORT_WEBSOCKET = 6,
    TRANSPORT_WEBSOCKET_IETF = 7
} ;
#line 3068 "tr.c"
typedef enum __anonenum_transport_t_673335178 transport_t;
#line 3083
enum __anonenum_raw_priority_t_974021638 {
    RAW_PRI_LO = 0,
    RAW_PRI_HI = 1
} ;
#line 3083 "tr.c"
typedef enum __anonenum_raw_priority_t_974021638 raw_priority_t;
#line 3087 "tr.c"
struct RAW {
   char *data ;
   struct RAW *next ;
   raw_priority_t priority ;
   int len ;
   int refcount ;
};
#line 3087 "tr.c"
typedef struct RAW RAW;
#line 3491
struct _callbackp ;
#line 3492 "tr.c"
struct _callbackp {
   ape_socket *client ;
   json_item *param ;
   struct _http_header_line *hlines ;
   struct USERS *call_user ;
   char const   *ip ;
   char const   *host ;
   char const   *cmd ;
   void *data ;
   subuser *call_subuser ;
   acetables *g_ape ;
   transport_t transport ;
   int chl ;
};
#line 3512 "tr.c"
struct _callback_hook {
   char const   *cmd ;
   void *data ;
   unsigned int (*func)(struct _callbackp * ) ;
   struct _callback_hook *next ;
};
#line 3555 "tr.c"
struct _ticks_callback {
   int ticks_need ;
   int delta ;
   int times ;
   unsigned int identifier ;
   unsigned int protect ;
   void *func ;
   void *params ;
   struct _ticks_callback *next ;
};
#line 3589
enum __anonenum_fdevent_handler_t_175319966 {
    EVENT_UNKNOWN = 0,
    EVENT_EPOLL = 1,
    EVENT_KQUEUE = 2,
    EVENT_DEVPOLL = 3,
    EVENT_POLL = 4,
    EVENT_SELECT = 5
} ;
#line 3589 "tr.c"
typedef enum __anonenum_fdevent_handler_t_175319966 fdevent_handler_t;
#line 3597 "tr.c"
struct _fdevent {
   int *basemem ;
   int (*add)(struct _fdevent * , int  , int  ) ;
   int (*remove)(struct _fdevent * , int  ) ;
   int (*poll)(struct _fdevent * , int  ) ;
   int (*get_current_fd)(struct _fdevent * , int  ) ;
   void (*growup)(struct _fdevent * ) ;
   int (*revent)(struct _fdevent * , int  ) ;
   int (*reload)(struct _fdevent * ) ;
   fdevent_handler_t handler ;
};
#line 4104 "tr.c"
struct _apeconfig_def {
   char *val ;
   struct _apeconfig_def *next ;
   char key[33] ;
};
#line 4104 "tr.c"
typedef struct _apeconfig_def apeconfig_def;
#line 4109 "tr.c"
struct apeconfig {
   apeconfig_def *def ;
   struct apeconfig *next ;
   char section[33] ;
};
#line 4119
struct _ace_callbacks ;
#line 4120 "tr.c"
struct _ace_callbacks {
   USERS *(*c_adduser)(USERS * , acetables * ) ;
   void (*c_deluser)(USERS * , int istmp , acetables * ) ;
   CHANNEL *(*c_mkchan)(char * , int  , acetables * ) ;
   void (*c_rmchan)(CHANNEL * , acetables * ) ;
   void (*c_join)(USERS * , CHANNEL * , acetables * ) ;
   void (*c_left)(USERS * , CHANNEL * , acetables * ) ;
   void (*c_tickuser)(subuser * , acetables * ) ;
   void (*c_post_raw_sub)(RAW * , subuser * , acetables * ) ;
   USERS *(*c_allocateuser)(ape_socket * , char const   * , char const   * , acetables * ) ;
   void (*c_addsubuser)(subuser * , acetables * ) ;
   void (*c_delsubuser)(subuser * , acetables * ) ;
};
#line 4134
struct _plug_config ;
#line 4135 "tr.c"
struct _plug_config {
   char *key ;
   char *value ;
   struct _plug_config *next ;
};
#line 4141
struct _ace_plugin_infos ;
#line 4141 "tr.c"
typedef struct _ace_plugin_infos ace_plugin_infos;
#line 4142 "tr.c"
typedef struct _ace_plugins ace_plugins;
#line 4143 "tr.c"
struct _ace_plugin_infos {
   char const   *name ;
   char const   *version ;
   char const   *author ;
   char const   *conf_file ;
   struct _plug_config *conf ;
};
#line 4151 "tr.c"
struct __anonstruct_fire_292218310 {
   unsigned short c_adduser ;
   unsigned short c_deluser ;
   unsigned short c_mkchan ;
   unsigned short c_rmchan ;
   unsigned short c_join ;
   unsigned short c_left ;
   unsigned short c_tickuser ;
   unsigned short c_post_raw_sub ;
   unsigned short c_allocateuser ;
   unsigned short c_addsubuser ;
   unsigned short c_delsubuser ;
};
#line 4151 "tr.c"
struct _ace_plugins {
   struct __anonstruct_fire_292218310 fire ;
   void *hPlug ;
   void (*loader)(acetables *g_ape ) ;
   void (*unloader)(acetables *g_ape ) ;
   char const   *modulename ;
   struct _ace_callbacks *cb ;
   ace_plugin_infos *infos ;
   ace_plugins *next ;
};
#line 96
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 317
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 444
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest , void const   * __restrict  __src , size_t __n ) ;
#line 514
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 879
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 1516 "tr.c"
int server_is_running  ;
#line 1816
extern json_item *json_new_object() ;
#line 1818
extern json_item *json_set_property_objN(json_item *obj , char const   *key , int keylen , json_item *value ) ;
#line 1820
extern json_item *json_set_property_strN(json_item *obj , char const   *key , int keylen , char const   *value , int valuelen ) ;
#line 1834
extern struct jsontring *json_to_string(json_item *head , struct jsontring *string , int free_tree ) ;
#line 1835
extern json_item *json_item_copy(json_item *cx , json_item *father ) ;
#line 1863
extern transpipe *get_pipe(char const   *pubid , acetables *g_ape ) ;
#line 1864
extern transpipe *get_pipe_strict(char const   *pubid , struct USERS *user , acetables *g_ape ) ;
#line 1865
extern void post_json_custom(json_item *jstr , struct USERS *user , struct _transpipe *pipe , acetables *g_ape ) ;
#line 1868
extern json_item *get_json_object_pipe(transpipe *pipe ) ;
#line 1924
extern json_item *get_json_object_channel(CHANNEL *chan ) ;
#line 2048
extern void send_error(USERS *user , char const   *msg , char const   *code , acetables *g_ape ) ;
#line 2053
extern json_item *get_json_object_user(USERS *user ) ;
#line 2113
extern int http_send_headers(http_headers_response *headers , char const   *default_h , unsigned int default_len , ape_socket *client , acetables *g_ape ) ;
#line 2263
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname , void const   *__optval , socklen_t __optlen ) ;
#line 2433
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 2435
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 3004
extern int sendbin(int sock , char const   *bin , unsigned int len , unsigned int burn_after_writing , acetables *g_ape ) ;
#line 3082
extern struct _transport_properties *transport_get_properties(transport_t transport , acetables *g_ape ) ;
#line 3095
RAW *forge_raw(char const   *raw , json_item *jlist ) ;
#line 3096
int free_raw(RAW *fraw ) ;
#line 3097
RAW *copy_raw(RAW *input ) ;
#line 3098
RAW *copy_raw_z(RAW *input ) ;
#line 3099
void post_raw(RAW *raw , USERS *user , acetables *g_ape ) ;
#line 3100
void post_raw_sub(RAW *raw , subuser *sub , acetables *g_ape ) ;
#line 3101
void post_raw_channel(RAW *raw , struct CHANNEL *chan , acetables *g_ape ) ;
#line 3102
void post_raw_restricted(RAW *raw , USERS *user , subuser *sub , acetables *g_ape ) ;
#line 3103
void post_raw_channel_restricted(RAW *raw , struct CHANNEL *chan , USERS *ruser , acetables *g_ape ) ;
#line 3104
void proxy_post_raw(RAW *raw , ape_proxy *proxy , acetables *g_ape ) ;
#line 3105
int post_raw_pipe(RAW *raw , char const   *pipe___0 , acetables *g_ape ) ;
#line 3106
int post_to_pipe(json_item *jlist , char const   *rawname , char const   *pipe___0 , subuser *from , acetables *g_ape ) ;
#line 3107
int send_raw_inline(ape_socket *client , transport_t transport , RAW *raw , acetables *g_ape ) ;
#line 3108
int send_raws(subuser *user , acetables *g_ape ) ;
#line 3109
struct _raw_pool *init_raw_pool(int n ) ;
#line 3110
struct _raw_pool *expend_raw_pool(struct _raw_pool *ptr , int n ) ;
#line 3111
void destroy_raw_pool(struct _raw_pool *ptr ) ;
#line 3461
extern void *xmalloc(size_t size ) ;
#line 4184 "tr.c"
RAW *forge_raw(char const   *raw , json_item *jlist ) 
{ 
  RAW *new_raw ;
  char unixtime[16] ;
  struct jsontring *string ;
  json_item *jstruct ;
  time_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 4189
  jstruct = (json_item *)((void *)0);
#line 4190
  tmp = time((time_t *)((void *)0));
#line 4190
  sprintf((char * __restrict  )(unixtime), (char const   * __restrict  )"%li", tmp);
#line 4191
  jstruct = json_new_object();
#line 4192
  tmp___0 = strlen((char const   *)(unixtime));
#line 4192
  json_set_property_strN(jstruct, "time", 4, (char const   *)(unixtime), (int )tmp___0);
#line 4193
  tmp___1 = strlen(raw);
#line 4193
  json_set_property_strN(jstruct, "raw", 3, raw, (int )tmp___1);
#line 4194
  json_set_property_objN(jstruct, "data", 4, jlist);
#line 4195
  string = json_to_string(jstruct, (struct jsontring *)((void *)0), 1);
#line 4196
  new_raw = (RAW *)xmalloc(sizeof(*new_raw));
#line 4197
  new_raw->len = (int )string->len;
#line 4198
  new_raw->next = (struct RAW *)((void *)0);
#line 4199
  new_raw->priority = (raw_priority_t )0;
#line 4200
  new_raw->refcount = 0;
#line 4201
  new_raw->data = string->jstring;
#line 4202
  free((void *)string);
#line 4203
  return (new_raw);
}
}
#line 4205 "tr.c"
int free_raw(RAW *fraw ) 
{ 


  {
#line 4207
  (fraw->refcount) --;
#line 4207
  if (fraw->refcount <= 0) {
#line 4208
    free((void *)fraw->data);
#line 4209
    free((void *)fraw);
#line 4210
    return (0);
  }
#line 4212
  return (fraw->refcount);
}
}
#line 4214 "tr.c"
RAW *copy_raw(RAW *input ) 
{ 
  RAW *new_raw ;

  {
#line 4217
  new_raw = (RAW *)xmalloc(sizeof(*new_raw));
#line 4218
  new_raw->len = input->len;
#line 4219
  new_raw->next = input->next;
#line 4220
  new_raw->priority = input->priority;
#line 4221
  new_raw->refcount = 0;
#line 4222
  new_raw->data = (char *)xmalloc(sizeof(char ) * (unsigned long )(new_raw->len + 1));
#line 4223
  memcpy((void * __restrict  )new_raw->data, (void const   * __restrict  )input->data, (size_t )(new_raw->len + 1));
#line 4224
  return (new_raw);
}
}
#line 4226 "tr.c"
RAW *copy_raw_z(RAW *input ) 
{ 


  {
#line 4228
  (input->refcount) ++;
#line 4229
  return (input);
}
}
#line 4231 "tr.c"
void post_raw_sub(RAW *raw , subuser *sub , acetables *g_ape ) 
{ 
  ace_plugins *cplug ;
  int add_size ;
  struct _raw_pool_user *pool ;
  struct _raw_pool_user *tmp ;

  {
#line 4233
  if (g_ape->plugins) {
#line 4233
    cplug = g_ape->plugins;
#line 4233
    while ((unsigned long )cplug != (unsigned long )((void *)0)) {
#line 4233
      if ((unsigned long )cplug->cb != (unsigned long )((void *)0)) {
#line 4233
        if ((unsigned long )(cplug->cb)->c_post_raw_sub != (unsigned long )((void *)0)) {
#line 4233
          if ((int )cplug->fire.c_post_raw_sub == 0) {
#line 4233
            cplug->fire.c_post_raw_sub = (unsigned short)1;
#line 4233
            (*((cplug->cb)->c_post_raw_sub))(raw, sub, g_ape);
#line 4233
            cplug->fire.c_post_raw_sub = (unsigned short)0;
#line 4233
            return;
#line 4233
            break;
          }
        }
      }
#line 4233
      cplug = cplug->next;
    }
  }
#line 4234
  add_size = 16;
#line 4235
  if ((unsigned int )raw->priority == 0U) {
#line 4235
    tmp = & sub->raw_pools.low;
  } else {
#line 4235
    tmp = & sub->raw_pools.high;
  }
#line 4235
  pool = tmp;
#line 4236
  (pool->nraw) ++;
#line 4236
  if (pool->nraw == pool->size) {
#line 4237
    pool->size += add_size;
#line 4238
    expend_raw_pool(pool->rawfoot, add_size);
  }
#line 4240
  (pool->rawfoot)->raw = raw;
#line 4241
  pool->rawfoot = (pool->rawfoot)->next;
#line 4242
  (sub->raw_pools.nraw) ++;
#line 4243
  return;
}
}
#line 4244 "tr.c"
void post_raw(RAW *raw , USERS *user , acetables *g_ape ) 
{ 
  subuser *sub ;
  RAW *tmp ;

  {
#line 4246
  sub = user->subuser;
#line 4247
  while ((unsigned long )sub != (unsigned long )((void *)0)) {
#line 4248
    tmp = copy_raw_z(raw);
#line 4248
    post_raw_sub(tmp, sub, g_ape);
#line 4249
    sub = sub->next;
  }
#line 4251
  return;
}
}
#line 4252 "tr.c"
void post_raw_restricted(RAW *raw , USERS *user , subuser *sub , acetables *g_ape ) 
{ 
  subuser *tSub ;
  RAW *tmp ;

  {
#line 4254
  tSub = user->subuser;
#line 4255
  if ((unsigned long )sub == (unsigned long )((void *)0)) {
#line 4256
    return;
  }
#line 4258
  while ((unsigned long )tSub != (unsigned long )((void *)0)) {
#line 4259
    if ((unsigned long )sub != (unsigned long )tSub) {
#line 4260
      tmp = copy_raw_z(raw);
#line 4260
      post_raw_sub(tmp, tSub, g_ape);
    }
#line 4262
    tSub = tSub->next;
  }
#line 4264
  return;
}
}
#line 4265 "tr.c"
void post_raw_channel(RAW *raw , struct CHANNEL *chan , acetables *g_ape ) 
{ 
  userslist *list ;

  {
#line 4268
  if ((unsigned long )chan == (unsigned long )((void *)0)) {
#line 4269
    return;
  } else
#line 4268
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
#line 4269
    return;
  } else
#line 4268
  if ((unsigned long )chan->head == (unsigned long )((void *)0)) {
#line 4269
    return;
  }
#line 4271
  list = chan->head;
#line 4272
  while (list) {
#line 4273
    post_raw(raw, list->userinfo, g_ape);
#line 4274
    list = list->next;
  }
#line 4276
  return;
}
}
#line 4277 "tr.c"
void post_raw_channel_restricted(RAW *raw , struct CHANNEL *chan , USERS *ruser , acetables *g_ape ) 
{ 
  userslist *list ;

  {
#line 4280
  if ((unsigned long )chan == (unsigned long )((void *)0)) {
#line 4281
    return;
  } else
#line 4280
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
#line 4281
    return;
  } else
#line 4280
  if ((unsigned long )chan->head == (unsigned long )((void *)0)) {
#line 4281
    return;
  }
#line 4283
  list = chan->head;
#line 4284
  while (list) {
#line 4285
    if ((unsigned long )list->userinfo != (unsigned long )ruser) {
#line 4286
      post_raw(raw, list->userinfo, g_ape);
    }
#line 4288
    list = list->next;
  }
#line 4290
  return;
}
}
#line 4291 "tr.c"
void proxy_post_raw(RAW *raw , ape_proxy *proxy , acetables *g_ape ) 
{ 
  ape_proxy_pipe *to ;
  transpipe *pipe___0 ;

  {
#line 4293
  to = proxy->to;
#line 4295
  while ((unsigned long )to != (unsigned long )((void *)0)) {
#line 4296
    pipe___0 = get_pipe((char const   *)(to->pipe), g_ape);
#line 4297
    if ((unsigned long )pipe___0 != (unsigned long )((void *)0)) {
#line 4297
      if (pipe___0->type == 1) {
#line 4298
        post_raw(raw, (USERS *)pipe___0->pipe, g_ape);
      }
    }
#line 4302
    to = to->next;
  }
#line 4304
  return;
}
}
#line 4305 "tr.c"
int post_raw_pipe(RAW *raw , char const   *pipe___0 , acetables *g_ape ) 
{ 
  transpipe *spipe ;

  {
#line 4308
  spipe = get_pipe(pipe___0, g_ape);
  {
#line 4309
  if (spipe->type == 0) {
#line 4310
    post_raw_channel(raw, (struct CHANNEL *)spipe->pipe, g_ape);
#line 4311
    return (1);
  } else {
#line 4313
    post_raw(raw, (USERS *)spipe->pipe, g_ape);
#line 4314
    return (1);
  }
  }
#line 4317
  return (0);
}
}
#line 4319 "tr.c"
int post_to_pipe(json_item *jlist , char const   *rawname , char const   *pipe___0 , subuser *from , acetables *g_ape ) 
{ 
  USERS *sender ;
  transpipe *recver ;
  transpipe *tmp ;
  json_item *jlist_copy ;
  RAW *newraw ;
  json_item *tmp___0 ;
  json_item *tmp___1 ;
  json_item *tmp___2 ;
  json_item *tmp___3 ;
  json_item *tmp___4 ;

  {
#line 4321
  sender = from->user;
#line 4322
  tmp = get_pipe_strict(pipe___0, sender, g_ape);
#line 4322
  recver = tmp;
#line 4323
  jlist_copy = (json_item *)((void *)0);
#line 4325
  if (sender) {
#line 4326
    if ((unsigned long )recver == (unsigned long )((void *)0)) {
#line 4327
      send_error(sender, "UNKNOWN_PIPE", "109", g_ape);
#line 4328
      return (0);
    }
#line 4330
    tmp___0 = get_json_object_user(sender);
#line 4330
    json_set_property_objN(jlist, "from", 4, tmp___0);
  }
  {
#line 4332
  if (sender->nsub > 1) {
#line 4333
    jlist_copy = json_item_copy(jlist, (json_item *)((void *)0));
#line 4334
    tmp___1 = get_json_object_pipe(recver);
#line 4334
    json_set_property_objN(jlist_copy, "pipe", 4, tmp___1);
#line 4335
    newraw = forge_raw(rawname, jlist_copy);
#line 4336
    post_raw_restricted(newraw, sender, from, g_ape);
  }
  }
#line 4338
  switch (recver->type) {
  case 1: 
#line 4340
  tmp___2 = get_json_object_user(sender);
#line 4340
  json_set_property_objN(jlist, "pipe", 4, tmp___2);
#line 4341
  newraw = forge_raw(rawname, jlist);
#line 4342
  post_raw(newraw, (USERS *)recver->pipe, g_ape);
#line 4343
  break;
  case 0: 
#line 4345
  if ((unsigned long )((CHANNEL *)recver->pipe)->head != (unsigned long )((void *)0)) {
#line 4345
    if ((unsigned long )(((CHANNEL *)recver->pipe)->head)->next != (unsigned long )((void *)0)) {
#line 4346
      tmp___3 = get_json_object_channel((CHANNEL *)recver->pipe);
#line 4346
      json_set_property_objN(jlist, "pipe", 4, tmp___3);
#line 4347
      newraw = forge_raw(rawname, jlist);
#line 4348
      post_raw_channel_restricted(newraw, (struct CHANNEL *)recver->pipe, sender, g_ape);
    }
  }
#line 4350
  break;
  case 3: 
#line 4352
  tmp___4 = get_json_object_user(sender);
#line 4352
  json_set_property_objN(jlist, "pipe", 4, tmp___4);
#line 4353
  post_json_custom(jlist, sender, recver, g_ape);
#line 4354
  break;
  default: 
#line 4356
  break;
  }
#line 4358
  return (1);
}
}
#line 4360 "tr.c"
int send_raw_inline(ape_socket *client , transport_t transport , RAW *raw , acetables *g_ape ) 
{ 
  struct _transport_properties *properties ;
  int finish ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  websocket_state *websocket ;
  char payload_head[32] ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int payload_size ;
  int payload_length ;
  unsigned short s ;
  unsigned short tmp___6 ;
  unsigned int s___0 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 4363
  finish = 1;
#line 4364
  properties = transport_get_properties(transport, g_ape);
#line 4365
  switch ((unsigned int )transport) {
  case 1U: 
#line 4367
  tmp = http_send_headers((http_headers_response *)((void *)0), "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: application/x-ape-event-stream\r\n\r\n                                                                                                                                                                                                                                                                ", 421U, client, g_ape);
#line 4367
  finish &= tmp;
#line 4368
  break;
  case 4U: 
#line 4370
  tmp___0 = http_send_headers((http_headers_response *)((void *)0), "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: application/x-dom-event-stream\r\n\r\n", 165U, client, g_ape);
#line 4370
  finish &= tmp___0;
#line 4371
  break;
  case 2U: 
#line 4373
  tmp___1 = http_send_headers((http_headers_response *)((void *)0), "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: application/javascript\r\n\r\n", 157U, client, g_ape);
#line 4373
  finish &= tmp___1;
#line 4374
  break;
  case 7U: 
  case 6U: 
#line 4377
  break;
  default: 
#line 4379
  tmp___2 = http_send_headers((http_headers_response *)((void *)0), "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: text/html\r\n\r\n", 144U, client, g_ape);
#line 4379
  finish &= tmp___2;
#line 4380
  break;
  }
  {
#line 4382
  if (properties->padding.left.val) {
#line 4383
    tmp___3 = sendbin(client->fd, (char const   *)properties->padding.left.val, (unsigned int )properties->padding.left.len, 0U, g_ape);
#line 4383
    finish &= tmp___3;
  }
  }
#line 4385
  if ((unsigned int )transport == 7U) {
#line 4386
    websocket = (websocket_state *)client->parser.data;
#line 4387
    if ((unsigned int )websocket->version == 2U) {
#line 4387
      tmp___4 = 132;
    } else {
#line 4387
      tmp___4 = 129;
    }
#line 4387
    payload_head[0] = (char )tmp___4;
#line 4387
    tmp___5 = 1U;
#line 4387
    while (! (tmp___5 >= 32U)) {
#line 4387
      payload_head[tmp___5] = (char)0;
#line 4387
      tmp___5 ++;
    }
#line 4388
    payload_size = raw->len + 2;
#line 4389
    payload_length = 0;
#line 4390
    if (payload_size <= 125) {
#line 4391
      payload_head[1] = (char )((int )((unsigned char )payload_size) & 127);
#line 4392
      payload_length = 2;
    } else
#line 4393
    if (payload_size <= 65535) {
#line 4394
      tmp___6 = htons((uint16_t )payload_size);
#line 4394
      s = tmp___6;
#line 4395
      payload_head[1] = (char)126;
#line 4396
      memcpy((void * __restrict  )(& payload_head[2]), (void const   * __restrict  )(& s), (size_t )2);
#line 4397
      payload_length = 4;
    } else
#line 4398
    if ((unsigned int )payload_size <= 4294967295U) {
#line 4399
      tmp___7 = htonl((uint32_t )payload_size);
#line 4399
      s___0 = tmp___7;
#line 4400
      payload_head[1] = (char)127;
#line 4401
      payload_head[2] = (char)0;
#line 4402
      payload_head[3] = (char)0;
#line 4403
      payload_head[4] = (char)0;
#line 4404
      payload_head[5] = (char)0;
#line 4405
      memcpy((void * __restrict  )(& payload_head[6]), (void const   * __restrict  )(& s___0), (size_t )4);
#line 4406
      payload_length = 10;
    }
#line 4408
    tmp___8 = sendbin(client->fd, (char const   *)(payload_head), (unsigned int )payload_length, 0U, g_ape);
#line 4408
    finish &= tmp___8;
  }
#line 4410
  tmp___9 = sendbin(client->fd, "[", 1U, 0U, g_ape);
#line 4410
  finish &= tmp___9;
#line 4411
  tmp___10 = sendbin(client->fd, (char const   *)raw->data, (unsigned int )raw->len, 0U, g_ape);
#line 4411
  finish &= tmp___10;
#line 4412
  tmp___11 = sendbin(client->fd, "]", 1U, 0U, g_ape);
#line 4412
  finish &= tmp___11;
  {
#line 4413
  if (properties->padding.right.val) {
#line 4414
    tmp___12 = sendbin(client->fd, (char const   *)properties->padding.right.val, (unsigned int )properties->padding.right.len, 0U, g_ape);
#line 4414
    finish &= tmp___12;
  }
  }
#line 4416
  free_raw(raw);
#line 4417
  return (finish);
}
}
#line 4419 "tr.c"
static unsigned int raws_size(subuser *user ) 
{ 
  struct _raw_pool *pool ;
  int state ;
  unsigned int size ;
  struct _raw_pool *pool_next ;
  struct _raw_pool *tmp ;

  {
#line 4422
  state = 0;
#line 4423
  size = 1U;
#line 4424
  if (user->raw_pools.nraw == 0) {
#line 4425
    return (0U);
  }
#line 4427
  if (user->raw_pools.high.nraw) {
#line 4428
    pool = (user->raw_pools.high.rawfoot)->prev;
  } else {
#line 4430
    pool = user->raw_pools.low.rawhead;
#line 4431
    state = 1;
  }
#line 4433
  while ((unsigned long )pool->raw != (unsigned long )((void *)0)) {
#line 4434
    if (state) {
#line 4434
      tmp = pool->next;
    } else {
#line 4434
      tmp = pool->prev;
    }
#line 4434
    pool_next = tmp;
#line 4435
    size += (unsigned int )((pool->raw)->len + 1);
#line 4436
    pool = pool_next;
#line 4437
    if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 4437
      goto _L;
    } else
#line 4437
    if ((unsigned long )pool->raw == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 4437
      if (! state) {
#line 4438
        pool = user->raw_pools.low.rawhead;
#line 4439
        state = 1;
      }
    }
  }
#line 4442
  return (size);
}
}
#line 4444 "tr.c"
int send_raws(subuser *user , acetables *g_ape ) 
{ 
  int finish ;
  int state ;
  struct _raw_pool *pool ;
  struct _transport_properties *properties ;
  int __state ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  websocket_state *websocket ;
  char payload_head[32] ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int payload_size ;
  int tmp___6 ;
  int payload_length ;
  unsigned short s ;
  unsigned short tmp___7 ;
  unsigned int s___0 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct _raw_pool *pool_next ;
  struct _raw_pool *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int __state___0 ;

  {
#line 4446
  finish = 1;
#line 4446
  state = 0;
#line 4449
  if (user->raw_pools.nraw == 0) {
#line 4450
    return (1);
  }
#line 4452
  while (1) {
#line 4452
    __state = 1;
#line 4452
    setsockopt((user->client)->fd, 6, 3, (void const   *)(& __state), (socklen_t )sizeof(__state));
#line 4452
    break;
  }
#line 4453
  properties = transport_get_properties((transport_t )(user->user)->transport, g_ape);
#line 4454
  if (! user->headers.sent) {
#line 4455
    user->headers.sent = 1;
#line 4456
    switch ((user->user)->transport) {
    case 1: 
#line 4458
    tmp = http_send_headers(user->headers.content, "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: application/x-ape-event-stream\r\n\r\n                                                                                                                                                                                                                                                                ", 421U, user->client, g_ape);
#line 4458
    finish &= tmp;
#line 4459
    break;
    case 4: 
#line 4461
    tmp___0 = http_send_headers(user->headers.content, "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: application/x-dom-event-stream\r\n\r\n", 165U, user->client, g_ape);
#line 4461
    finish &= tmp___0;
#line 4462
    break;
    case 2: 
#line 4464
    tmp___1 = http_send_headers(user->headers.content, "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: application/javascript\r\n\r\n", 157U, user->client, g_ape);
#line 4464
    finish &= tmp___1;
#line 4465
    break;
    case 7: 
    case 6: 
#line 4468
    break;
    default: 
#line 4470
    tmp___2 = http_send_headers(user->headers.content, "HTTP/1.1 200 OK\r\nPragma: no-cache\r\nCache-Control: no-cache, must-revalidate\r\nExpires: Thu, 27 Dec 1986 07:30:00 GMT\r\nContent-Type: text/html\r\n\r\n", 144U, user->client, g_ape);
#line 4470
    finish &= tmp___2;
#line 4471
    break;
    }
  }
  {
#line 4474
  if (properties->padding.left.val) {
#line 4475
    tmp___3 = sendbin((user->client)->fd, (char const   *)properties->padding.left.val, (unsigned int )properties->padding.left.len, 0U, g_ape);
#line 4475
    finish &= tmp___3;
  }
  }
#line 4477
  if (user->raw_pools.high.nraw) {
#line 4478
    pool = (user->raw_pools.high.rawfoot)->prev;
  } else {
#line 4480
    pool = user->raw_pools.low.rawhead;
#line 4481
    state = 1;
  }
#line 4483
  if ((user->user)->transport == 7) {
#line 4484
    websocket = (websocket_state *)(user->client)->parser.data;
#line 4485
    if ((unsigned int )websocket->version == 2U) {
#line 4485
      tmp___4 = 132;
    } else {
#line 4485
      tmp___4 = 129;
    }
#line 4485
    payload_head[0] = (char )tmp___4;
#line 4485
    tmp___5 = 1U;
#line 4485
    while (! (tmp___5 >= 32U)) {
#line 4485
      payload_head[tmp___5] = (char)0;
#line 4485
      tmp___5 ++;
    }
#line 4486
    tmp___6 = (int )raws_size(user);
#line 4486
    payload_size = tmp___6;
#line 4487
    payload_length = 0;
#line 4488
    if (payload_size <= 125) {
#line 4489
      payload_head[1] = (char )((int )((unsigned char )payload_size) & 127);
#line 4490
      payload_length = 2;
    } else
#line 4491
    if (payload_size <= 65535) {
#line 4492
      tmp___7 = htons((uint16_t )payload_size);
#line 4492
      s = tmp___7;
#line 4493
      payload_head[1] = (char)126;
#line 4494
      memcpy((void * __restrict  )(& payload_head[2]), (void const   * __restrict  )(& s), (size_t )2);
#line 4495
      payload_length = 4;
    } else
#line 4496
    if ((unsigned int )payload_size <= 4294967295U) {
#line 4497
      tmp___8 = htonl((uint32_t )payload_size);
#line 4497
      s___0 = tmp___8;
#line 4498
      payload_head[1] = (char)127;
#line 4499
      payload_head[2] = (char)0;
#line 4500
      payload_head[3] = (char)0;
#line 4501
      payload_head[4] = (char)0;
#line 4502
      payload_head[5] = (char)0;
#line 4503
      memcpy((void * __restrict  )(& payload_head[6]), (void const   * __restrict  )(& s___0), (size_t )4);
#line 4504
      payload_length = 10;
    }
#line 4506
    tmp___9 = sendbin((user->client)->fd, (char const   *)(payload_head), (unsigned int )payload_length, 0U, g_ape);
#line 4506
    finish &= tmp___9;
  }
#line 4508
  tmp___10 = sendbin((user->client)->fd, "[", 1U, 0U, g_ape);
#line 4508
  finish &= tmp___10;
#line 4509
  while ((unsigned long )pool->raw != (unsigned long )((void *)0)) {
#line 4510
    if (state) {
#line 4510
      tmp___11 = pool->next;
    } else {
#line 4510
      tmp___11 = pool->prev;
    }
#line 4510
    pool_next = tmp___11;
#line 4511
    tmp___12 = sendbin((user->client)->fd, (char const   *)(pool->raw)->data, (unsigned int )(pool->raw)->len, 0U, g_ape);
#line 4511
    finish &= tmp___12;
#line 4512
    if ((unsigned long )pool_next != (unsigned long )((void *)0)) {
#line 4512
      if ((unsigned long )pool_next->raw != (unsigned long )((void *)0)) {
#line 4513
        tmp___13 = sendbin((user->client)->fd, ",", 1U, 0U, g_ape);
#line 4513
        finish &= tmp___13;
      } else {
#line 4512
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4512
    if (! state) {
#line 4512
      if (user->raw_pools.low.nraw) {
#line 4513
        tmp___13 = sendbin((user->client)->fd, ",", 1U, 0U, g_ape);
#line 4513
        finish &= tmp___13;
      } else {
#line 4512
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4515
      tmp___14 = sendbin((user->client)->fd, "]", 1U, 0U, g_ape);
#line 4515
      finish &= tmp___14;
#line 4516
      if ((unsigned long )properties != (unsigned long )((void *)0)) {
#line 4516
        if ((unsigned long )properties->padding.right.val != (unsigned long )((void *)0)) {
#line 4517
          tmp___15 = sendbin((user->client)->fd, (char const   *)properties->padding.right.val, (unsigned int )properties->padding.right.len, 0U, g_ape);
#line 4517
          finish &= tmp___15;
        }
      }
    }
#line 4520
    free_raw(pool->raw);
#line 4521
    pool->raw = (struct RAW *)((void *)0);
#line 4522
    pool = pool_next;
#line 4523
    if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 4523
      goto _L___1;
    } else
#line 4523
    if ((unsigned long )pool->raw == (unsigned long )((void *)0)) {
      _L___1: /* CIL Label */ 
#line 4523
      if (! state) {
#line 4524
        pool = user->raw_pools.low.rawhead;
#line 4525
        state = 1;
      }
    }
  }
#line 4528
  user->raw_pools.high.nraw = 0;
#line 4529
  user->raw_pools.low.nraw = 0;
#line 4530
  user->raw_pools.nraw = 0;
#line 4531
  user->raw_pools.high.rawfoot = user->raw_pools.high.rawhead;
#line 4532
  user->raw_pools.low.rawfoot = user->raw_pools.low.rawhead;
#line 4533
  while (1) {
#line 4533
    __state___0 = 0;
#line 4533
    setsockopt((user->client)->fd, 6, 3, (void const   *)(& __state___0), (socklen_t )sizeof(__state___0));
#line 4533
    break;
  }
#line 4534
  return (finish);
}
}
#line 4536 "tr.c"
struct _raw_pool *init_raw_pool(int n ) 
{ 
  int i ;
  struct _raw_pool *pool ;
  struct _raw_pool *tmp ;

  {
#line 4539
  tmp = (struct _raw_pool *)xmalloc(sizeof(*pool) * (unsigned long )n);
#line 4539
  pool = tmp;
#line 4540
  i = 0;
#line 4540
  while (i < n) {
#line 4541
    (pool + i)->raw = (struct RAW *)((void *)0);
#line 4542
    if (i == n - 1) {
#line 4542
      (pool + i)->next = (struct _raw_pool *)((void *)0);
    } else {
#line 4542
      (pool + i)->next = pool + (i + 1);
    }
#line 4543
    if (i == 0) {
#line 4543
      (pool + i)->prev = (struct _raw_pool *)((void *)0);
    } else {
#line 4543
      (pool + i)->prev = pool + (i - 1);
    }
#line 4544
    (pool + i)->start = i == 0;
#line 4540
    i ++;
  }
#line 4546
  return (pool);
}
}
#line 4548 "tr.c"
struct _raw_pool *expend_raw_pool(struct _raw_pool *ptr , int n ) 
{ 
  struct _raw_pool *pool ;
  struct _raw_pool *tmp ;

  {
#line 4550
  tmp = init_raw_pool(n);
#line 4550
  pool = tmp;
#line 4551
  ptr->next = pool;
#line 4552
  pool->prev = ptr;
#line 4553
  return (pool);
}
}
#line 4555 "tr.c"
void destroy_raw_pool(struct _raw_pool *ptr ) 
{ 
  struct _raw_pool *pool ;
  struct _raw_pool *tpool ;

  {
#line 4557
  pool = ptr;
#line 4557
  tpool = (struct _raw_pool *)((void *)0);
#line 4558
  while ((unsigned long )pool != (unsigned long )((void *)0)) {
#line 4559
    if ((unsigned long )pool->raw != (unsigned long )((void *)0)) {
#line 4560
      free_raw(pool->raw);
    }
#line 4562
    if (pool->start) {
#line 4563
      if ((unsigned long )tpool != (unsigned long )((void *)0)) {
#line 4564
        free((void *)tpool);
      }
#line 4566
      tpool = pool;
    }
#line 4568
    pool = pool->next;
  }
  {
#line 4571
  free((void *)tpool);
  }
#line 4573
  return;
}
}
